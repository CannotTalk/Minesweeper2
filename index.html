<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper 2</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px 0;
            background-color: #f0f0f0;
            font-family: 'Press Start 2P', cursive;
            transition: background-color 0.5s ease;
            overflow: hidden; /* Prevent scrollbars during animation */
        }
        body.game-over {
            background-color: #ff4444;
        }
        body.low-time {
            background-color: #FDBE00; /* Yamabuki-iro */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 12px;
            position: relative;
            width: 90%;
            max-width: 350px;
        }
        /* Blind Rule Display */
        #blind-rule-display {
            font-family: 'DotGothic16', sans-serif;
            font-size: 13px;
            color: #333;
            margin-bottom: 8px;
            line-height: 1.5;
            min-height: 35px;
            width: 100%;
            max-width: 314px;
            padding: 5px 8px;
            box-sizing: border-box;
            border: 2px solid #8B0000;
            background-color: #fff0f0;
            display: none;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #blind-rule-display.visible {
            display: block;
        }
        #blind-rule-display strong {
            font-size: 14px;
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            text-align: left;
            font-family: 'Press Start 2P', cursive;
        }
         #blind-rule-display span {
             display: block;
             text-align: center;
         }

        /* Game Header Styling */
        #game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 314px;
            margin-bottom: 5px;
            padding: 0 5px;
            box-sizing: border-box;
            min-height: 30px;
            position: relative;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(15, 20px);
            border: 2px solid #333;
            background-color: #b4c687;
            padding: 4px;
            margin-top: 5px;
            margin-bottom: 10px;
        }
        .square {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 11px;
            user-select: none;
            background-color: #eee;
            line-height: 1;
            overflow: hidden;
            text-align: center;
        }
        .hidden { background-color: #ddd; }
        .revealed { background-color: #b4c687; }
        .mine { background-color: #ff4444; color: #000; font-size: 12px; }
        .mine-clicked { background-color: #cc0000; color: #fff; font-size: 14px; }
        .flag-wrong {
            background-color: #fdd !important;
            color: #000;
            font-weight: bold;
            font-size: 14px;
        }

        #reset-button {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 8px;
            font-family: 'Press Start 2P', cursive;
        }
        #rules-button {
            position: static;
            padding: 5px 8px;
            font-size: 10px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            background-color: #e0e0e0;
            border: 1px solid #999;
            border-radius: 3px;
            z-index: 10;
            margin-top: 0;
            order: 3;
        }
        #rules-button:hover { background-color: #d0d0d0; }

        #info-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 314px;
        }

        #message-box {
            font-size: 12px;
            color: #333;
            margin-bottom: 2px;
            height: 14px;
            text-align: center;
        }
        #active-rules-display {
            font-size: 9px;
            color: #555;
            margin-top: 0px;
            margin-bottom: 8px;
            line-height: 1.3;
            text-align: center;
            min-height: 40px;
        }
        #active-rules-display div { margin-bottom: 2px; }
        #active-rules-display .rule-display-hide {}
        #active-rules-display .rule-display-directional { color: #1a759f; }
        #active-rules-display .rule-display-oddEven { color: #0000CD; }
        #active-rules-display .rule-display-areaValue { color: #902094; }
        #active-rules-display .rule-display-naturalNumber { color: #2E8B57; }
        #active-rules-display .rule-display-noNumbers {}
        #active-rules-display .rule-display-noFlags {}
        #active-rules-display .rule-display-standard {}
        #active-rules-display .rule-display-timeBomb { color: #DC143C; }
        #active-rules-display .rule-display-gameOverOnTimeOnly { color: #8B4513; }
        #active-rules-display .rule-display-blind { color: #8B0000; font-weight: bold; }


        .timer {
            font-size: 14px;
            color: #333;
            text-align: center;
            order: 2;
            flex-grow: 1;
            margin: 0;
            transition: color 0.3s ease;
        }
        .timer.blinking-black span { animation: blink-black 1s infinite; }
        .timer.blinking-red span { animation: blink-red 1s infinite; }
        .timer.blinking-basketball span { animation: blink-basketball 0.8s infinite; }

        @keyframes blink-black { 0%, 49% { color: black; } 50%, 100% { color: #333; } }
        @keyframes blink-red { 0%, 49% { color: red; } 50%, 100% { color: #333; } }
        @keyframes blink-basketball { 0%, 49% { color: #ff0000; } 50%, 100% { color: #000000; } }

        .switch { position: relative; display: inline-block; width: 40px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 18px; }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:focus + .slider { box-shadow: 0 0 1px #2196F3; }
        input:checked + .slider:before { transform: translateX(22px); }
        .slider.round { border-radius: 18px; }
        .slider.round:before { border-radius: 50%; }

        .special-square { font-size: 9px; }
        .odd-even-square { color: #0000CD; font-weight: bold; }
        .area-value-square{ color: #902094; font-weight: bold; font-size: 9px; }
        .directional-square { color: #1a759f; font-weight: bold; font-size: 9px; }
        .natural-number-square { color: #2E8B57; font-weight: bold; }
        .number-1 { color: #000000; } .number-2 { color: #000000; } .number-3 { color: #000000; }
        .number-4 { color: #000000; } .number-5 { color: #000000; } .number-6 { color: #000000; }
        .number-7 { color: #000000; } .number-8 { color: #000000; }

        #debug-buttons { display: flex; margin-top: 8px; }
        #debug-buttons button { margin-left: 4px; padding: 6px 10px; font-size: 10px; cursor: pointer; font-family: 'Press Start 2P', cursive; }
        #debug-buttons button:first-child { margin-left: 0; }

        #mode-toggle-buttons { display: none; user-select: none; order: 1; }
        #mode-toggle-buttons.visible { display: flex; gap: 5px; }
        .mode-button { font-size: 20px; padding: 3px 6px; cursor: pointer; border: 2px solid #888; background-color: #eee; border-radius: 5px; line-height: 1; }
        .mode-button.active { background-color: #ccc; border-color: #333; box-shadow: inset 0 0 5px rgba(0,0,0,0.2); }
        #flag-mode-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #eee; border-color: #888; box-shadow: none; }

        /* --- Popup Styles --- */
         #popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 99; display: none; }
         #rules-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px; background-color: #fdfdfd; border: 2px solid #333; border-radius: 8px; z-index: 100; display: none; font-size: 11px; box-shadow: 0 5px 20px rgba(0,0,0,0.25); font-family: sans-serif; color: #333; flex-direction: column; }
         #popup-overlay.visible, #rules-popup.visible { display: flex !important; }
         .popup-header { padding: 15px 20px 0 20px; }
         .popup-header h2 { margin-top: 0; margin-bottom: 15px; font-size: 18px; text-align: center; font-family: 'Press Start 2P', cursive; color: #111; }
         .rules-content { max-height: 65vh; overflow-y: auto; padding: 0 20px 10px 20px; }
         #rules-popup h3 { font-size: 14px; margin-bottom: 10px; margin-top: 18px; border-bottom: 1px solid #ccc; padding-bottom: 4px; font-weight: bold; }
         #rules-popup h4 { font-size: 13px; margin-bottom: 6px; margin-top: 12px; font-weight: bold; color: #555; }
         #rules-popup p { margin-bottom: 12px; line-height: 1.5; font-size: 12px; }
         #close-popup-button { position: absolute; top: 8px; right: 8px; background: none; border: 1px solid transparent; font-size: 26px; font-weight: bold; color: #777; cursor: pointer; font-family: sans-serif; line-height: 1; padding: 0 6px; transition: color 0.2s, border-color 0.2s; }
         #close-popup-button:hover, #close-popup-button:focus { color: #000; border-color: #ccc; outline: none; }
         #rules-popup .setting-section { background-color: #f0f0f0; padding: 10px 15px; border-radius: 4px; margin-bottom: 12px; border: 1px solid #ddd; }
         #rules-popup .setting-label { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0; font-size: 12px; margin-top: 8px; font-weight: bold; font-family: 'Press Start 2P', cursive; }
         #rules-popup .switch { margin-left: 8px; }
         .popup-footer { padding: 10px 20px; text-align: right; border-top: 1px solid #ccc; background-color: #f9f9f9; margin-top: auto; }
         #save-settings-button { padding: 6px 12px; font-size: 12px; font-family: 'Press Start 2P', cursive; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 3px; }
         #save-settings-button:hover { background-color: #45a049; }

         #mine-slider { width: 100%; cursor: pointer; margin-top: 5px; }
         #mine-count-display { font-weight: bold; margin-left: 5px; font-family: sans-serif; font-size: 13px;}
         .slider-label { display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-family: 'Press Start 2P', cursive; margin-bottom: 5px; }

        .reset-rule-button { font-size: 9px; padding: 2px 6px; margin-left: 10px; cursor: pointer; background-color: #ddd; border: 1px solid #bbb; border-radius: 3px; font-family: sans-serif; }
        .reset-rule-button:hover { background-color: #ccc; }

        #hide-rate-control { margin-top: 10px; }
        #hide-rate-slider-label { display: flex; justify-content: space-between; align-items: center; font-size: 11px; margin-bottom: 3px; font-weight: normal; }
        #hide-rate-display { font-weight: bold; margin-left: 5px; font-family: sans-serif; font-size: 12px;}
        #hide-rate-slider { width: 100%; cursor: pointer; }
        .setting-section[data-rule-id="hide"] > #hide-rate-control:not(.enabled) { opacity: 0.5; pointer-events: none; }

        .pc-op-mode-label { display: block; margin-bottom: 5px; font-size: 12px; cursor: pointer; }
        .pc-op-mode-label input[type="radio"] { margin-right: 5px; }
        #pc-op-mode-section { display: block; }
        body.touch-device #pc-op-mode-section { display: none; }
        body:not(.touch-device)[data-pc-op-mode="mouse"] #mode-toggle-buttons { display: none; }

        #timer-start-display { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(2); font-size: 48px; font-family: 'Press Start 2P', cursive; color: #000; border-radius: 5px; z-index: 101; opacity: 0; pointer-events: none; transition: transform 0.4s ease-out, opacity 0.4s ease-out, top 0.4s ease-out, left 0.4s ease-out, font-size 0.4s ease-out, color 0.4s ease-out; animation: start-blink 1s infinite; }
        #timer-start-display.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #timer-start-display.move-to-corner { top: 25px; left: 50%; transform: translateX(-50%) scale(0.6); font-size: 14px; opacity: 0; color: #333; animation: none; }
        .timer.hide-during-intro { visibility: hidden; }

        @keyframes start-blink { 0%, 49% { opacity: 1; } 50%, 100% { opacity: 0.5; } }

        body.timer-intro-active * { pointer-events: none !important; }
        body.timer-intro-active #rules-popup, body.timer-intro-active #popup-overlay { pointer-events: auto !important; }
        body.timer-intro-active #rules-popup * { pointer-events: auto !important; }

        #time-bomb-details { margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc; }
        #time-bomb-details > div { margin-bottom: 10px; }
        .time-input-group { display: flex; align-items: center; margin-bottom: 6px; }
        .time-input-group label { display: inline-block; width: 65px; text-align: right; margin-right: 5px; font-size: 11px; font-family: sans-serif; font-weight: bold; }
        .time-input-group input[type="number"] { width: 40px; padding: 4px; font-size: 12px; font-family: sans-serif; border: 1px solid #ccc; border-radius: 3px; text-align: right; -moz-appearance: textfield; appearance: textfield; }
        .time-input-group input[type="number"]::-webkit-outer-spin-button, .time-input-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .time-input-group span.colon { font-size: 14px; font-weight: bold; margin: 0 3px; font-family: sans-serif; }

        #time-bomb-random-switch-label, #game-over-on-time-only-label { display: flex; align-items: center; justify-content: space-between; font-size: 11px; font-weight: normal; font-family: 'Press Start 2P', cursive; margin-bottom: 5px; }
        .time-setting-note { display: block; font-size: 10px; color: #666; margin-top: 4px; font-family: sans-serif; text-align: center; }
        .hidden-setting { display: none !important; }
        .disabled-setting { opacity: 0.5; pointer-events: none; }
        .disabled-setting input, .disabled-setting button, .disabled-setting .switch { cursor: not-allowed !important; }

        #rules-popup .setting-section[data-rule-id="blind"] {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #aaa;
        }

    </style>
</head>
<body data-flags-enabled="true">
    <div id="game-container">
         <div id="blind-rule-display">
             <strong>Blind Rule: Title</strong>
             <span>Description</span>
         </div>
        <div id="game-header">
             <div id="mode-toggle-buttons">
                 <button id="dig-mode-button" class="mode-button active" title="掘るモード">⛏️</button>
                 <button id="flag-mode-button" class="mode-button" title="旗モード">🚩</button>
             </div>
            <div class="timer" id="timer-container">
                Time: <span id="timer-value">00.00</span>
            </div>
            <button id="rules-button">Rules & Settings</button>
        </div>

        <div id="board"></div>

        <div id="info-controls">
            <div id="message-box"></div>
            <div id="active-rules-display"></div>
            <button id="reset-button">Reset</button>
            <div id="debug-buttons">
                <button id="reveal-non-mines">Open Non-Mines</button>
                <button id="reveal-all">Open All</button>
            </div>
        </div>
    </div>

    <div id="timer-start-display"></div>

    <div id="popup-overlay"></div>
    <div id="rules-popup">
        <button id="close-popup-button" aria-label="閉じる">×</button>
        <div class="popup-header">
             <h2>ルールと設定</h2>
        </div>
        <div class="rules-content">
            <h3>基本ルール</h3>
            <p>クリックしてマスを開きます。数字は周囲8マスにある地雷の数を示します。(ブラインド「あべこべ」有効時は安全地帯の数)<br>
               地雷のマスを開かずに、地雷以外のすべてのマスを開くとクリアです。<br>
               通常は、右クリック(PC)または長押し/旗モード(スマホ)で旗 (🚩) を立てられます。<br>
               <b>「フラグなしモード」</b>が有効な場合、旗を立てることはできません。<br>
               <b>「時限爆弾モード」</b>では制限時間内にクリアする必要があります。
               <b>「ブラインドモード」</b>では追加の制限ルールがランダムに適用されます。
            </p>

            <h3>ゲーム設定</h3>
            <div class="setting-section" id="pc-op-mode-section">
                <h4>PC操作モード</h4>
                 <p style="margin-bottom: 8px;">マウス操作（右クリックで旗🚩を立てる）か、ボタン切り替え操作（画面上部の⛏️/🚩ボタン）かを選択します。<b>この設定は即時反映されます。</b><br>※フラグなしモード有効時は右クリック/🚩ボタンは無効です。</p>
                <label class="pc-op-mode-label">
                    <input type="radio" name="pc-op-mode" value="mouse" checked> マウス操作 (右クリックで🚩)
                </label>
                <label class="pc-op-mode-label">
                    <input type="radio" name="pc-op-mode" value="button"> ボタン切り替え操作 (⛏️/🚩)
                </label>
            </div>
             <div class="setting-section" data-rule-id="mines">
                 <div class="slider-label">
                     <span>地雷の数:</span>
                     <span id="mine-count-display">30</span>
                     <button class="reset-rule-button" data-rule="mines">デフォルトに戻す</button>
                 </div>
                 <input type="range" id="mine-slider" min="0" max="225" value="30">
                 <p style="font-size:10px; margin-top: 5px;">変更を適用するには「設定を保存」を押してください。</p>
             </div>
            <div class="setting-section" data-rule-id="noFlags">
                <h4>フラグなしモード (No Flags)</h4>
                <p>旗を立てる操作が無効になります。記憶力だけで挑戦！</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="noFlags">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="no-flags-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="setting-section" data-rule-id="timeBomb">
                <h4>時限爆弾モード (Time Bomb Mode)</h4>
                <p>制限時間内にクリアしないとゲームオーバーになります。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="timeBomb">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="time-bomb-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
                <div id="time-bomb-details" class="hidden-setting">
                     <div id="time-bomb-random-switch-label">
                         <span>ランダムな時間</span>
                         <label class="switch">
                              <input type="checkbox" id="time-bomb-random-switch">
                              <span class="slider round"></span>
                         </label>
                     </div>
                     <div id="time-bomb-random-settings" class="hidden-setting">
                         <div class="time-input-group">
                             <label for="time-bomb-min-hours">最小時間:</label>
                             <input type="number" id="time-bomb-min-hours" min="0" step="1" value="0"><span class="colon">:</span>
                             <input type="number" id="time-bomb-min-minutes" min="0" max="59" step="1" value="3"><span class="colon">:</span>
                             <input type="number" id="time-bomb-min-seconds" min="0" max="59" step="1" value="0">
                         </div>
                         <div class="time-input-group">
                             <label for="time-bomb-max-hours">最大時間:</label>
                             <input type="number" id="time-bomb-max-hours" min="0" step="1" value="0"><span class="colon">:</span>
                             <input type="number" id="time-bomb-max-minutes" min="0" max="59" step="1" value="8"><span class="colon">:</span>
                             <input type="number" id="time-bomb-max-seconds" min="0" max="59" step="1" value="0">
                         </div>
                         <span class="time-setting-note">(HH:MM:SS 形式)</span>
                     </div>
                     <div id="time-bomb-fixed-settings" class="hidden-setting">
                         <div class="time-input-group">
                             <label for="time-bomb-fixed-hours">時間設定:</label>
                             <input type="number" id="time-bomb-fixed-hours" min="0" step="1" value="0"><span class="colon">:</span>
                             <input type="number" id="time-bomb-fixed-minutes" min="0" max="59" step="1" value="5"><span class="colon">:</span>
                             <input type="number" id="time-bomb-fixed-seconds" min="0" max="59" step="1" value="0">
                          </div>
                          <span class="time-setting-note">(HH:MM:SS 形式)</span>
                     </div>
                     <div id="game-over-on-time-only-label">
                         <span>時間切れでのみゲームオーバー</span>
                         <label class="switch">
                              <input type="checkbox" id="game-over-on-time-only-switch">
                              <span class="slider round"></span>
                         </label>
                     </div>
                     <p style="font-size:10px; margin-top: 0; text-align: center;">
                        有効時、地雷を踏むとペナルティ(15秒)が課されます。<br>ただし、全ての地雷を踏んだ場合もゲームオーバーになります。
                     </p>
                </div>
            </div>

            <h3>表示設定</h3>
             <div class="setting-section" data-rule-id="numbers">
                 <h4>数字マス生成 (Numbers Squares)</h4>
                 <p>オンの場合、地雷に隣接するマスに数字が表示されます。<br>
                    オフの場合、数字が表示されるべきマスは、可能な限り他の特殊マス (NaturalNumber, Directional, AreaValue, OddEven) に置き換えられ、残りはハイドマス (・) になります。</p>
                 <div class="setting-label">
                      <span>有効</span>
                       <div>
                         <button class="reset-rule-button" data-rule="numbers">デフォルト</button>
                         <label class="switch">
                             <input type="checkbox" id="number-switch" checked>
                             <span class="slider round"></span>
                         </label>
                      </div>
                 </div>
             </div>

            <h3>特殊マス設定</h3>
            <p>これらのマスは数字の代わりにヒントを表示します。同じ種類の特殊マス（ハイドマスを除く）は隣り合いません。「数字マス生成」がオフの場合、これらの設定は可能な限り適用されるようになります。<br>変更を適用するには「設定を保存」を押してください。</p>

            <div class="setting-section" data-rule-id="hide">
                <h4>ハイドマス (Concealment Squares)</h4>
                <p>数字が表示される代わりに「・」が表示されます。周囲の状況から数字を推測する必要があります。</p>
                <div class="setting-label">
                     <span>有効</span>
                      <div>
                          <button class="reset-rule-button" data-rule="hide">デフォルト</button>
                          <label class="switch">
                              <input type="checkbox" id="hide-switch" checked>
                              <span class="slider round"></span>
                          </label>
                      </div>
                </div>
                <div id="hide-rate-control" class="enabled">
                    <div id="hide-rate-slider-label">
                        <span>最大割合:</span>
                        <span id="hide-rate-display">10%</span>
                    </div>
                    <input type="range" id="hide-rate-slider" min="5" max="50" step="5" value="10">
                </div>
            </div>

            <div class="setting-section" data-rule-id="directional">
                <h4>ディレクションマス (Directional Squares)</h4>
                 <p>方向(<b>T</b>:上, <b>B</b>:下, <b>L</b>:左, <b>R</b>:右)とその方向にある地雷/安全地帯の数を表示します (例:「R4」)。<br>
                   指定された方向の地雷/安全地帯のみをカウントします。矢印が指す方向に最低1マス存在する場合のみ生成されます。同じ方向への連鎖はしません。</p>
                <div class="setting-label">
                     <span>有効</span>
                      <div>
                          <button class="reset-rule-button" data-rule="directional">デフォルト</button>
                          <label class="switch">
                              <input type="checkbox" id="directional-switch" checked>
                              <span class="slider round"></span>
                          </label>
                      </div>
                </div>
            </div>

             <div class="setting-section" data-rule-id="oddEven">
                <h4>オッドイーブンマス (OddEven Squares)</h4>
                 <p>数字の代わりに、周囲の地雷/安全地帯数が奇数(Odd)か偶数(Even)かを示します。「Ev」または「Od」で表示されます。</p>
                <div class="setting-label">
                     <span>有効</span>
                      <div>
                          <button class="reset-rule-button" data-rule="oddEven">デフォルト</button>
                          <label class="switch">
                              <input type="checkbox" id="odd-even-switch" checked>
                              <span class="slider round"></span>
                          </label>
                      </div>
                 </div>
             </div>

             <div class="setting-section" data-rule-id="areaValue">
                <h4>エリアバリューマス (Range Value Squares)</h4>
                 <p>数字の代わりに、周囲の地雷/安全地帯数のおおよその範囲を示します。「~3」、「4~6」、「7~」で表示されます。</p>
                 <div class="setting-label">
                      <span>有効</span>
                      <div>
                         <button class="reset-rule-button" data-rule="areaValue">デフォルト</button>
                         <label class="switch">
                             <input type="checkbox" id="area-value-switch" checked>
                             <span class="slider round"></span>
                         </label>
                     </div>
                 </div>
             </div>

             <div class="setting-section" data-rule-id="naturalNumber">
                <h4>ナチュラルナンバーマス (Natural Number Squares)</h4>
                <p>周囲の地雷/安全地帯数が素数(2,3,5,7)の場合はその数字を、素数でない場合(0,1,4,6,8)は最も近い素数との差を表示します。例えば、「-1」(1)、「±1」(4)、「+1」(8)のように表示されます。</p>
                <div class="setting-label">
                     <span>有効</span>
                      <div>
                         <button class="reset-rule-button" data-rule="naturalNumber">デフォルト</button>
                         <label class="switch">
                             <input type="checkbox" id="natural-number-switch" checked>
                             <span class="slider round"></span>
                         </label>
                     </div>
                 </div>
             </div>

             <div class="setting-section" data-rule-id="blind">
                 <h3>ブラインドモード (Blind Mode)</h3>
                <p>マインスイーパーを遊び尽くした人向け。有効にすると一部の設定が固定され、ランダムな追加ルールが適用されます。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="blind">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="blind-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
             </div>

        </div>
        <div class="popup-footer">
            <button id="save-settings-button">設定を保存してリセット</button>
        </div>
    </div>

    <script>
        // --- Constants ---
        const gridSize = 15;
        const MINE_PENALTY_MS = 15000;
        const BASKETBALL_INTERVAL_MS = 10000;

        const defaultSettings = {
             numMines: 30, enableNoFlags: false, enableTimeBomb: false, timeLimitRandom: true,
             timeLimitMinMs: 180000, timeLimitMaxMs: 480000, timeLimitFixedMs: 300000,
             gameOverOnTimeOnly: false, enableNumbers: true, enableHide: true, hideRateMax: 0.10,
             enableDirectional: true, enableOddEven: true, enableAreaValue: true, enableNaturalNumber: true,
             enableBlind: false
        };

        // Blind Mode Constants
        const BLIND_MINE_MIN = 40; const BLIND_MINE_MAX = 50;
        const BLIND_HIDE_RATE = 0.20; const BLIND_DIRECTIONAL_RATE = 0.10;
        const BLIND_ODDEVEN_RATE = 0.10; const BLIND_AREAVALUE_RATE = 0.05;
        const BLIND_NATURALNUMBER_RATE = 0.05;
        const MIN_ERROR_RATE = 0.10;

        // --- Blind Rules Definition ---
        const blindRules = [
             { id: 'basketball', title: 'バスケットボール', description: '10秒に1回は安全なマスを開けなければならない', bgColor: '#ffe4e1', borderColor: '#dc143c' },
             { id: 'error', title: '過失誤差', description: '数字マスが±1されることがある', bgColor: '#fffacd', borderColor: '#ffd700' },
             { id: 'anomaly', title: '異常発生', description: '特定の特殊マスの生成率が増加する', bgColor: '#e6e6fa', borderColor: '#9370db' },
             { id: 'noChain', title: '完璧な感染対策', description: '0マスでの連鎖が発生しない', bgColor: '#f0fff0', borderColor: '#2e8b57' },
             { id: 'torus', title: 'トーラス', description: '盤面の上下左右の端がつながる', bgColor: '#add8e6', borderColor: '#4682b4' },
             { id: 'abekobe', title: 'あべこべ', description: '数字マスは安全地帯の数を示すようになる', bgColor: '#fafad2', borderColor: '#b8860b' }
        ];
        const specialSquareTypes = ['hide', 'directional', 'oddEven', 'areaValue', 'naturalNumber'];
        const specialSquareNamesJP = { hide: 'ハイドマス', directional: 'ディレクションマス', oddEven: 'オッドイーブンマス', areaValue: 'エリアバリューマス', naturalNumber: 'ナチュラルナンバーマス' };

        let numMines = defaultSettings.numMines;
        let currentMaxHideRate = defaultSettings.hideRateMax;
        let currentMaxOddEvenRate = 0.10; let currentMaxAreaValueRate = 0.03;
        let currentMaxDirectionalRate = 0.05; let currentMaxNaturalNumberRate = 0.05;

        // --- Board State ---
        let board = []; let minesLeft = numMines; let revealedNonMineCount = 0;
        let clickedMineCount = 0; let gameOver = false; let timerInterval = null;
        let elapsedMilliseconds = 0; let remainingMilliseconds = 0; let timeLimitMilliseconds = 0;
        const timerUpdateInterval = 50; let gameStarted = false; let startTime = 0; let penaltyOffsetMs = 0;

        // Interaction Mode State
        let currentInteractionMode = 'dig'; let pcOperationMode = 'mouse'; let isTouch = false; let justFlagged = false;

        // Blind Mode State
        let activeBlindRule = null; let basketballTimerInterval = null;
        let basketballRemainingMs = BASKETBALL_INTERVAL_MS; let basketballStartTime = 0;
        let anomalyTargetType = null; let currentAnomalyRate = 0;

        // --- Get DOM Elements ---
        const boardElement = document.getElementById('board');
        const resetButton = document.getElementById('reset-button');
        const messageBox = document.getElementById('message-box');
        const timerContainer = document.getElementById('timer-container');
        const timerSpan = document.getElementById('timer-value');
        const body = document.body;
        const revealNonMinesButton = document.getElementById('reveal-non-mines');
        const revealAllButton = document.getElementById('reveal-all');
        const rulesButton = document.getElementById('rules-button');
        const rulesPopup = document.getElementById('rules-popup');
        const closePopupButton = document.getElementById('close-popup-button');
        const popupOverlay = document.getElementById('popup-overlay');
        const numberSwitch = document.getElementById('number-switch');
        const hideSwitch = document.getElementById('hide-switch');
        const directionalSwitch = document.getElementById('directional-switch');
        const oddEvenSwitch = document.getElementById('odd-even-switch');
        const areaValueSwitch = document.getElementById('area-value-switch');
        const mineSlider = document.getElementById('mine-slider');
        const mineCountDisplay = document.getElementById('mine-count-display');
        const modeToggleButtonsContainer = document.getElementById('mode-toggle-buttons');
        const digModeButton = document.getElementById('dig-mode-button');
        const flagModeButton = document.getElementById('flag-mode-button');
        const pcOpModeRadios = document.querySelectorAll('input[name="pc-op-mode"]');
        const pcOpModeSection = document.getElementById('pc-op-mode-section');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const activeRulesDisplay = document.getElementById('active-rules-display');
        const hideRateSlider = document.getElementById('hide-rate-slider');
        const hideRateDisplay = document.getElementById('hide-rate-display');
        const hideRateControl = document.getElementById('hide-rate-control');
        const resetRuleButtons = document.querySelectorAll('.reset-rule-button');
        const noFlagsSwitch = document.getElementById('no-flags-switch');
        const naturalNumberSwitch = document.getElementById('natural-number-switch');
        const timeBombSwitch = document.getElementById('time-bomb-switch');
        const timeBombDetails = document.getElementById('time-bomb-details');
        const timeBombRandomSwitch = document.getElementById('time-bomb-random-switch');
        const timeBombRandomSettings = document.getElementById('time-bomb-random-settings');
        const timeBombFixedSettings = document.getElementById('time-bomb-fixed-settings');
        const timeBombMinHoursInput = document.getElementById('time-bomb-min-hours');
        const timeBombMinMinutesInput = document.getElementById('time-bomb-min-minutes');
        const timeBombMinSecondsInput = document.getElementById('time-bomb-min-seconds');
        const timeBombMaxHoursInput = document.getElementById('time-bomb-max-hours');
        const timeBombMaxMinutesInput = document.getElementById('time-bomb-max-minutes');
        const timeBombMaxSecondsInput = document.getElementById('time-bomb-max-seconds');
        const timeBombFixedHoursInput = document.getElementById('time-bomb-fixed-hours');
        const timeBombFixedMinutesInput = document.getElementById('time-bomb-fixed-minutes');
        const timeBombFixedSecondsInput = document.getElementById('time-bomb-fixed-seconds');
        const gameOverOnTimeOnlySwitch = document.getElementById('game-over-on-time-only-switch');
        const timerStartDisplay = document.getElementById('timer-start-display');
        const blindSwitch = document.getElementById('blind-switch');
        const blindRuleDisplay = document.getElementById('blind-rule-display');
        const minesSettingSection = document.querySelector('.setting-section[data-rule-id="mines"]');
        const noFlagsSettingSection = document.querySelector('.setting-section[data-rule-id="noFlags"]');
        const timeBombSettingSection = document.querySelector('.setting-section[data-rule-id="timeBomb"]');
        const numbersSettingSection = document.querySelector('.setting-section[data-rule-id="numbers"]');
        const hideSettingSection = document.querySelector('.setting-section[data-rule-id="hide"]');
        const directionalSettingSection = document.querySelector('.setting-section[data-rule-id="directional"]');
        const oddEvenSettingSection = document.querySelector('.setting-section[data-rule-id="oddEven"]');
        const areaValueSettingSection = document.querySelector('.setting-section[data-rule-id="areaValue"]');
        const naturalNumberSettingSection = document.querySelector('.setting-section[data-rule-id="naturalNumber"]');

        // --- Settings (Current Applied) ---
        let enableNoFlags = defaultSettings.enableNoFlags;
        let enableTimeBomb = defaultSettings.enableTimeBomb;
        let timeLimitRandom = defaultSettings.timeLimitRandom;
        let timeLimitMinMs = defaultSettings.timeLimitMinMs;
        let timeLimitMaxMs = defaultSettings.timeLimitMaxMs;
        let timeLimitFixedMs = defaultSettings.timeLimitFixedMs;
        let gameOverOnTimeOnly = defaultSettings.gameOverOnTimeOnly;
        let enableNumbers = defaultSettings.enableNumbers;
        let enableHide = defaultSettings.enableHide;
        let hideRateMax = defaultSettings.hideRateMax;
        let enableDirectional = defaultSettings.enableDirectional;
        let enableOddEven = defaultSettings.enableOddEven;
        let enableAreaValue = defaultSettings.enableAreaValue;
        let enableNaturalNumber = defaultSettings.enableNaturalNumber;
        let enableBlind = defaultSettings.enableBlind;

        let pendingSettings = { ...defaultSettings };

        // --- Helper Functions ---
        function parseInputsToMs(hoursInput, minutesInput, secondsInput) {
            const h = parseInt(hoursInput?.value, 10) || 0;
            const m = parseInt(minutesInput?.value, 10) || 0;
            const s = parseInt(secondsInput?.value, 10) || 0;
            if (h < 0 || m < 0 || m > 59 || s < 0 || s > 59) { console.warn("Invalid time input values:", h, m, s); return null; }
            return (h * 3600 + m * 60 + s) * 1000;
        }

        function formatMsToInputs(ms, hoursInput, minutesInput, secondsInput) {
            if (typeof ms !== 'number' || ms < 0) { ms = 0; }
            const totalSeconds = Math.floor(ms / 1000); const seconds = totalSeconds % 60;
            const totalMinutes = Math.floor(totalSeconds / 60); const minutes = totalMinutes % 60;
            const hours = Math.floor(totalMinutes / 60);
            if (hoursInput) { hoursInput.value = hours; } if (minutesInput) { minutesInput.value = minutes; } if (secondsInput) { secondsInput.value = seconds; }
        }

        function formatMsToDisplayTime(ms, includeHoursForce = false) {
            if (typeof ms !== 'number' || ms < 0) { return '00:00'; }
            const totalSeconds = Math.floor(ms / 1000); const seconds = String(totalSeconds % 60).padStart(2, '0');
            const totalMinutes = Math.floor(totalSeconds / 60); const minutes = String(totalMinutes % 60).padStart(2, '0');
            const hours = Math.floor(totalMinutes / 60);
            if (includeHoursForce || hours > 0) { return `${String(hours).padStart(2, '0')}:${minutes}:${seconds}`; }
            else { return `${minutes}:${seconds}`; }
        }

        function initializeSliders() {
            if (pendingSettings.numMines < 0) { pendingSettings.numMines = 0; } if (pendingSettings.numMines > 225) { pendingSettings.numMines = 225; }
            mineSlider.value = pendingSettings.numMines; mineCountDisplay.textContent = pendingSettings.numMines;
            hideRateSlider.value = pendingSettings.hideRateMax * 100; hideRateDisplay.textContent = `${hideRateSlider.value}%`;
            hideRateControl.classList.toggle('enabled', pendingSettings.enableHide);
        }
        initializeSliders();

        // --- Device Detection and UI Initialization ---
        function detectTouch() {
            isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouch) { document.body.classList.add('touch-device'); pcOperationMode = 'button'; }
            else {
                document.body.classList.remove('touch-device');
                const currentPcOpRadio = document.querySelector(`input[name="pc-op-mode"][value="${pcOperationMode}"]`);
                if (currentPcOpRadio) { currentPcOpRadio.checked = true; }
                else { pcOperationMode = 'mouse'; document.querySelector('input[name="pc-op-mode"][value="mouse"]').checked = true; }
                document.body.dataset.pcOpMode = pcOperationMode;
            }
            updateModeButtonsVisibility();
        }

        function updateModeButtonsVisibility() {
            modeToggleButtonsContainer.classList.toggle('visible', isTouch || pcOperationMode === 'button');
            flagModeButton.disabled = enableNoFlags;
        }

        // --- Event Listeners ---
        resetButton.addEventListener('click', resetGame);
        revealNonMinesButton.addEventListener('click', revealNonMines);
        revealAllButton.addEventListener('click', revealAll);
        rulesButton.addEventListener('click', openPopup);
        closePopupButton.addEventListener('click', closePopup);
        popupOverlay.addEventListener('click', closePopup);
        numberSwitch.addEventListener('change', () => { pendingSettings.enableNumbers = numberSwitch.checked; });
        hideSwitch.addEventListener('change', () => { pendingSettings.enableHide = hideSwitch.checked; hideRateControl.classList.toggle('enabled', pendingSettings.enableHide); });
        directionalSwitch.addEventListener('change', () => { pendingSettings.enableDirectional = directionalSwitch.checked; });
        oddEvenSwitch.addEventListener('change', () => { pendingSettings.enableOddEven = oddEvenSwitch.checked; });
        areaValueSwitch.addEventListener('change', () => { pendingSettings.enableAreaValue = areaValueSwitch.checked; });
        noFlagsSwitch.addEventListener('change', () => { pendingSettings.enableNoFlags = noFlagsSwitch.checked; updateSettingsUI(pendingSettings); });
        naturalNumberSwitch.addEventListener('change', () => { pendingSettings.enableNaturalNumber = naturalNumberSwitch.checked; });
        timeBombSwitch.addEventListener('change', () => { pendingSettings.enableTimeBomb = timeBombSwitch.checked; updateSettingsUI(pendingSettings); updateTimeBombDetailsVisibility(); });
        timeBombRandomSwitch.addEventListener('change', () => { pendingSettings.timeLimitRandom = timeBombRandomSwitch.checked; updateTimeBombInputVisibility(); });
        gameOverOnTimeOnlySwitch.addEventListener('change', () => { pendingSettings.gameOverOnTimeOnly = gameOverOnTimeOnlySwitch.checked; });
        blindSwitch.addEventListener('change', () => { pendingSettings.enableBlind = blindSwitch.checked; updateSettingsUI(pendingSettings); });
        mineSlider.addEventListener('input', () => { pendingSettings.numMines = parseInt(mineSlider.value, 10); mineCountDisplay.textContent = pendingSettings.numMines; });
        hideRateSlider.addEventListener('input', () => { pendingSettings.hideRateMax = parseInt(hideRateSlider.value, 10) / 100; hideRateDisplay.textContent = `${hideRateSlider.value}%`; });
        digModeButton.addEventListener('click', () => switchMode('dig'));
        flagModeButton.addEventListener('click', () => switchMode('flag'));
        pcOpModeRadios.forEach(radio => radio.addEventListener('change', handlePcOperationModeChange));
        saveSettingsButton.addEventListener('click', saveSettingsAndReset);
        resetRuleButtons.forEach(button => button.addEventListener('click', handleResetRule));

        function handleTimeInputChange() {
             let minMs = parseInputsToMs(timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
             let maxMs = parseInputsToMs(timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
             let fixedMs = parseInputsToMs(timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
             if (minMs !== null) { if (maxMs !== null && minMs > maxMs) { maxMs = minMs; formatMsToInputs(maxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput); } pendingSettings.timeLimitMinMs = minMs; }
             else { formatMsToInputs(pendingSettings.timeLimitMinMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput); }
             if (maxMs !== null) { if (minMs !== null && maxMs < minMs) { minMs = maxMs; formatMsToInputs(minMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput); pendingSettings.timeLimitMinMs = minMs; } pendingSettings.timeLimitMaxMs = maxMs; }
             else { formatMsToInputs(pendingSettings.timeLimitMaxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput); }
             if (fixedMs !== null) { if (fixedMs <= 0) { fixedMs = defaultSettings.timeLimitFixedMs; formatMsToInputs(fixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput); } pendingSettings.timeLimitFixedMs = fixedMs; }
             else { formatMsToInputs(pendingSettings.timeLimitFixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput); }
        }
        [timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput].forEach(input => { if (input) { input.addEventListener('change', handleTimeInputChange); } });

        // --- Popup Functions ---
        function updateTimeBombDetailsVisibility() {
            const showDetails = pendingSettings.enableTimeBomb && !pendingSettings.enableBlind;
            timeBombDetails.classList.toggle('hidden-setting', !showDetails);
            if (showDetails) { updateTimeBombInputVisibility(); }
        }

        function updateTimeBombInputVisibility() {
            timeBombRandomSettings.classList.toggle('hidden-setting', !pendingSettings.timeLimitRandom);
            timeBombFixedSettings.classList.toggle('hidden-setting', pendingSettings.timeLimitRandom);
        }

        function updateSettingsUI(settings) {
            const isBlindActive = settings.enableBlind;
            const isNoFlagsActive = settings.enableNoFlags;
            const isTimeBombActive = settings.enableTimeBomb;
            const blindDisabledSections = [ minesSettingSection, noFlagsSettingSection, timeBombSettingSection, numbersSettingSection, hideSettingSection, directionalSettingSection, oddEvenSettingSection, areaValueSettingSection, naturalNumberSettingSection ];
            blindDisabledSections.forEach(section => section?.classList.toggle('disabled-setting', isBlindActive));
             const blindSettingSection = document.querySelector('.setting-section[data-rule-id="blind"]');
             const disableBlind = isNoFlagsActive || isTimeBombActive;
             blindSettingSection?.classList.toggle('disabled-setting', disableBlind);
             if (disableBlind && blindSwitch.checked) { blindSwitch.checked = false; settings.enableBlind = false; }
            noFlagsSettingSection?.classList.toggle('disabled-setting', isBlindActive);
            timeBombSettingSection?.classList.toggle('disabled-setting', isBlindActive);
            if (isBlindActive) {
                 if (noFlagsSwitch.checked) { noFlagsSwitch.checked = false; settings.enableNoFlags = false; }
                 if (timeBombSwitch.checked) { timeBombSwitch.checked = false; settings.enableTimeBomb = false; }
            }
            hideRateControl.classList.toggle('enabled', settings.enableHide && !isBlindActive);
            updateTimeBombDetailsVisibility();
        }

        function openPopup() {
             pendingSettings = {
                numMines: numMines, enableNoFlags: enableNoFlags, enableTimeBomb: enableTimeBomb, timeLimitRandom: timeLimitRandom,
                timeLimitMinMs: timeLimitMinMs, timeLimitMaxMs: timeLimitMaxMs, timeLimitFixedMs: timeLimitFixedMs, gameOverOnTimeOnly: gameOverOnTimeOnly,
                enableNumbers: enableNumbers, enableHide: enableHide, hideRateMax: hideRateMax, enableDirectional: enableDirectional,
                enableOddEven: enableOddEven, enableAreaValue: enableAreaValue, enableNaturalNumber: enableNaturalNumber, enableBlind: enableBlind
            };
            mineSlider.value = pendingSettings.numMines; mineCountDisplay.textContent = pendingSettings.numMines; noFlagsSwitch.checked = pendingSettings.enableNoFlags;
            numberSwitch.checked = pendingSettings.enableNumbers; hideSwitch.checked = pendingSettings.enableHide; hideRateSlider.value = pendingSettings.hideRateMax * 100;
            hideRateDisplay.textContent = `${hideRateSlider.value}%`; directionalSwitch.checked = pendingSettings.enableDirectional; oddEvenSwitch.checked = pendingSettings.enableOddEven;
            areaValueSwitch.checked = pendingSettings.enableAreaValue; naturalNumberSwitch.checked = pendingSettings.enableNaturalNumber; blindSwitch.checked = pendingSettings.enableBlind;
            timeBombSwitch.checked = pendingSettings.enableTimeBomb; timeBombRandomSwitch.checked = pendingSettings.timeLimitRandom;
            formatMsToInputs(pendingSettings.timeLimitMinMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
            formatMsToInputs(pendingSettings.timeLimitMaxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
            formatMsToInputs(pendingSettings.timeLimitFixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
            gameOverOnTimeOnlySwitch.checked = pendingSettings.gameOverOnTimeOnly;
            updateSettingsUI(pendingSettings);
            const currentPcOpRadio = document.querySelector(`input[name="pc-op-mode"][value="${pcOperationMode}"]`);
            if (currentPcOpRadio) { currentPcOpRadio.checked = true; }
            rulesPopup.classList.add('visible'); popupOverlay.classList.add('visible');
        }

        function closePopup() { rulesPopup.classList.remove('visible'); popupOverlay.classList.remove('visible'); }

        function handleResetRule(event) {
            const rule = event.target.dataset.rule; if (!rule) { return; }
            switch (rule) {
                case 'mines': pendingSettings.numMines = defaultSettings.numMines; mineSlider.value = pendingSettings.numMines; mineCountDisplay.textContent = pendingSettings.numMines; break;
                case 'noFlags': pendingSettings.enableNoFlags = defaultSettings.enableNoFlags; noFlagsSwitch.checked = pendingSettings.enableNoFlags; break;
                case 'timeBomb': pendingSettings.enableTimeBomb = defaultSettings.enableTimeBomb; pendingSettings.timeLimitRandom = defaultSettings.timeLimitRandom; pendingSettings.timeLimitMinMs = defaultSettings.timeLimitMinMs; pendingSettings.timeLimitMaxMs = defaultSettings.timeLimitMaxMs; pendingSettings.timeLimitFixedMs = defaultSettings.timeLimitFixedMs; pendingSettings.gameOverOnTimeOnly = defaultSettings.gameOverOnTimeOnly; timeBombSwitch.checked = pendingSettings.enableTimeBomb; timeBombRandomSwitch.checked = pendingSettings.timeLimitRandom; gameOverOnTimeOnlySwitch.checked = pendingSettings.gameOverOnTimeOnly; formatMsToInputs(pendingSettings.timeLimitMinMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput); formatMsToInputs(pendingSettings.timeLimitMaxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput); formatMsToInputs(pendingSettings.timeLimitFixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput); break;
                case 'numbers': pendingSettings.enableNumbers = defaultSettings.enableNumbers; numberSwitch.checked = pendingSettings.enableNumbers; break;
                case 'hide': pendingSettings.enableHide = defaultSettings.enableHide; pendingSettings.hideRateMax = defaultSettings.hideRateMax; hideSwitch.checked = pendingSettings.enableHide; hideRateSlider.value = pendingSettings.hideRateMax * 100; hideRateDisplay.textContent = `${hideRateSlider.value}%`; break;
                case 'directional': pendingSettings.enableDirectional = defaultSettings.enableDirectional; directionalSwitch.checked = pendingSettings.enableDirectional; break;
                case 'oddEven': pendingSettings.enableOddEven = defaultSettings.enableOddEven; oddEvenSwitch.checked = pendingSettings.enableOddEven; break;
                case 'areaValue': pendingSettings.enableAreaValue = defaultSettings.enableAreaValue; areaValueSwitch.checked = pendingSettings.enableAreaValue; break;
                case 'naturalNumber': pendingSettings.enableNaturalNumber = defaultSettings.enableNaturalNumber; naturalNumberSwitch.checked = pendingSettings.enableNaturalNumber; break;
                case 'blind': pendingSettings.enableBlind = defaultSettings.enableBlind; blindSwitch.checked = pendingSettings.enableBlind; break;
            }
            updateSettingsUI(pendingSettings);
        }

        function saveSettingsAndReset() {
            if (pendingSettings.enableTimeBomb && !pendingSettings.enableBlind) { handleTimeInputChange(); }
            enableBlind = pendingSettings.enableBlind;
            if (enableBlind) {
                 enableNoFlags = false; enableTimeBomb = false; gameOverOnTimeOnly = false; enableNumbers = true; enableHide = true;
                 hideRateMax = BLIND_HIDE_RATE; enableDirectional = true; enableOddEven = true; enableAreaValue = true; enableNaturalNumber = true;
            } else {
                 numMines = pendingSettings.numMines; enableNoFlags = pendingSettings.enableNoFlags; enableTimeBomb = pendingSettings.enableTimeBomb;
                 timeLimitRandom = pendingSettings.timeLimitRandom; timeLimitMinMs = pendingSettings.timeLimitMinMs; timeLimitMaxMs = pendingSettings.timeLimitMaxMs;
                 timeLimitFixedMs = pendingSettings.timeLimitFixedMs; gameOverOnTimeOnly = pendingSettings.gameOverOnTimeOnly;
                 enableNumbers = pendingSettings.enableNumbers; enableHide = pendingSettings.enableHide; hideRateMax = pendingSettings.hideRateMax;
                 enableDirectional = pendingSettings.enableDirectional; enableOddEven = pendingSettings.enableOddEven;
                 enableAreaValue = pendingSettings.enableAreaValue; enableNaturalNumber = pendingSettings.enableNaturalNumber;
            }
            updateNoFlagsUI();
            resetGame();
            closePopup();
        }

        function handlePcOperationModeChange(event) { pcOperationMode = event.target.value; document.body.dataset.pcOpMode = pcOperationMode; updateModeButtonsVisibility(); switchMode('dig'); }

        function switchMode(newMode) {
            if ((enableNoFlags && newMode === 'flag') || newMode === currentInteractionMode) { return; }
            currentInteractionMode = newMode;
            digModeButton.classList.toggle('active', newMode === 'dig');
            flagModeButton.classList.toggle('active', newMode === 'flag');
        }

        function updateActiveRulesDisplay() {
            let rulesHtml = '';
             if (enableBlind) { rulesHtml += `<div class="rule-display-blind">Blind Mode Active!</div>`; }
             if (!enableBlind) {
                 if (enableNoFlags) { rulesHtml += `<div class="rule-display-noFlags">No Flags</div>`; }
                 if (enableTimeBomb) { const timeDesc = formatMsToDisplayTime(timeLimitMilliseconds, true); rulesHtml += `<div class="rule-display-timeBomb">Time Bomb (${timeDesc})</div>`; if (gameOverOnTimeOnly) { rulesHtml += `<div class="rule-display-gameOverOnTimeOnly">Game Over on Time Only</div>`; } }
                 if (!enableNumbers) { rulesHtml += `<div class="rule-display-noNumbers">No Numbers</div>`; }
                 if (enableHide) { rulesHtml += `<div class="rule-display-hide">Concealment Sq. (${Math.round(hideRateMax*100)}% Max)</div>`; }
                 if (enableDirectional) { rulesHtml += `<div class="rule-display-directional">Directional Squares</div>`; }
                 if (enableOddEven) { rulesHtml += `<div class="rule-display-oddEven">OddEven Squares</div>`; }
                 if (enableAreaValue) { rulesHtml += `<div class="rule-display-areaValue">Range Value Squares</div>`; }
                 if (enableNaturalNumber) { rulesHtml += `<div class="rule-display-naturalNumber">Natural Number Squares</div>`; }
             }
            if (!rulesHtml) { rulesHtml = '<div class="rule-display-standard">Standard Rules</div>'; }
            activeRulesDisplay.innerHTML = rulesHtml;
        }

        function updateBlindRuleDisplay() {
             if (enableBlind && activeBlindRule) {
                 let description = activeBlindRule.description;
                 if (activeBlindRule.id === 'anomaly' && anomalyTargetType) {
                     const targetNameJP = specialSquareNamesJP[anomalyTargetType] || anomalyTargetType;
                     description = `${targetNameJP}の最大生成率が${Math.round(currentAnomalyRate * 100)}%になる`;
                 }
                 blindRuleDisplay.innerHTML = `<strong>Blind: ${activeBlindRule.title}</strong><span>${description}</span>`;
                 blindRuleDisplay.classList.add('visible');
                 blindRuleDisplay.style.backgroundColor = activeBlindRule.bgColor || '#fff0f0';
                 blindRuleDisplay.style.borderColor = activeBlindRule.borderColor || '#8B0000';
             } else {
                 blindRuleDisplay.classList.remove('visible'); blindRuleDisplay.innerHTML = '';
                 blindRuleDisplay.style.backgroundColor = ''; blindRuleDisplay.style.borderColor = '';
             }
         }

        function updateNoFlagsUI() {
            const flagsAllowed = !enableNoFlags;
            body.setAttribute('data-flags-enabled', flagsAllowed);
            flagModeButton.disabled = !flagsAllowed;
            if (!flagsAllowed && currentInteractionMode === 'flag') { switchMode('dig'); }
            updateModeButtonsVisibility();
        }

        // --- Game Logic Functions ---
        function resetGame() {
            gameOver = true; clearInterval(timerInterval); timerInterval = null; clearInterval(basketballTimerInterval); basketballTimerInterval = null;
            elapsedMilliseconds = 0; remainingMilliseconds = 0; timeLimitMilliseconds = 0; basketballRemainingMs = BASKETBALL_INTERVAL_MS;
            startTime = 0; basketballStartTime = 0; gameStarted = false; revealedNonMineCount = 0; clickedMineCount = 0; penaltyOffsetMs = 0;
            minesLeft = numMines; switchMode('dig'); activeBlindRule = null; anomalyTargetType = null; currentAnomalyRate = 0;
            messageBox.textContent = ''; body.classList.remove('game-over', 'low-time', 'timer-intro-active'); body.style.backgroundColor = '';
            timerContainer.classList.remove('blinking-black', 'blinking-red', 'blinking-basketball', 'hide-during-intro');
            timerStartDisplay.classList.remove('visible', 'move-to-corner'); timerStartDisplay.style.animation = 'none';
            updateBlindRuleDisplay(); updateTimerDisplay(); updateActiveRulesDisplay(); updateNoFlagsUI();
            setTimeout(createBoard, 50);
         }

        function createBoard() {
            board = []; gameOver = false; revealedNonMineCount = 0; clickedMineCount = 0; penaltyOffsetMs = 0; boardElement.innerHTML = '';
            activeBlindRule = null; anomalyTargetType = null; currentAnomalyRate = 0;

            if (enableBlind) {
                 activeBlindRule = blindRules[Math.floor(Math.random() * blindRules.length)];
                 numMines = Math.floor(Math.random() * (BLIND_MINE_MAX - BLIND_MINE_MIN + 1)) + BLIND_MINE_MIN;
                 minesLeft = numMines;
                 currentMaxHideRate = BLIND_HIDE_RATE; currentMaxDirectionalRate = BLIND_DIRECTIONAL_RATE;
                 currentMaxOddEvenRate = BLIND_ODDEVEN_RATE; currentMaxAreaValueRate = BLIND_AREAVALUE_RATE;
                 currentMaxNaturalNumberRate = BLIND_NATURALNUMBER_RATE;
                 if (activeBlindRule.id === 'anomaly') {
                     anomalyTargetType = specialSquareTypes[Math.floor(Math.random() * specialSquareTypes.length)];
                     currentAnomalyRate = Math.random() * (0.75 - 0.50) + 0.50; // 50% - 75%
                     console.log(`Anomaly Target: ${anomalyTargetType}, Rate: ${currentAnomalyRate}`);
                 }
                 enableNoFlags = false; enableTimeBomb = false; timeLimitMilliseconds = 0; elapsedMilliseconds = 0;
                 updateBlindRuleDisplay();
            } else {
                 minesLeft = numMines; updateBlindRuleDisplay();
                 currentMaxHideRate = hideRateMax; currentMaxOddEvenRate = 0.10; currentMaxAreaValueRate = 0.03;
                 currentMaxDirectionalRate = 0.05; currentMaxNaturalNumberRate = 0.05;
                 if (enableTimeBomb) {
                     timeLimitMilliseconds = timeLimitRandom ? Math.floor(Math.random() * (Math.max(0, timeLimitMaxMs) - Math.max(0, timeLimitMinMs) + 1)) + Math.max(0, timeLimitMinMs) : Math.max(1000, timeLimitFixedMs);
                     remainingMilliseconds = timeLimitMilliseconds;
                 } else { timeLimitMilliseconds = 0; elapsedMilliseconds = 0; }
            }
            updateTimerDisplay(); updateActiveRulesDisplay(); updateNoFlagsUI();

            for (let i = 0; i < gridSize; i++) {
                board[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    board[i][j] = {
                        isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0, originalAdjacentMines: 0, adjacentSafe: 0,
                        isHide: false, isOddEven: false, isAreaValue: false, isDirectional: false, isNaturalNumber: false,
                        oddEvenValue: null, areaValue: null, direction: null, directionalCount: null, directionalSymbol: null, naturalNumberValue: null,
                        isAdjusted: false, element: document.createElement('div')
                    };
                    const sq = board[i][j]; const el = sq.element;
                    el.classList.add('square', 'hidden'); el.dataset.row = i; el.dataset.col = j;
                    el.addEventListener('click', () => handleSquareInteraction(i, j));
                    el.addEventListener('contextmenu', (e) => { e.preventDefault(); if (!isTouch && pcOperationMode === 'mouse' && !enableNoFlags && !gameOver) { handleFlagAction(i, j); } });
                    let pt;
                    el.addEventListener('touchstart', (e) => { if (isTouch && !enableNoFlags && !gameOver) { clearTimeout(pt); pt = setTimeout(() => { e.preventDefault(); handleFlagAction(i, j); justFlagged = true; setTimeout(() => { justFlagged = false; }, 50); }, 500); } }, { passive: false });
                    el.addEventListener('touchend', () => clearTimeout(pt)); el.addEventListener('touchmove', () => clearTimeout(pt));
                    boardElement.appendChild(el);
                }
            }
            plantMines(); calculateAdjacentMines(); applySpecialSquares(); updateMinesLeftDisplay();
            if (enableTimeBomb && !enableBlind && timeLimitMilliseconds > 0) { timerContainer.classList.add('hide-during-intro'); setTimeout(startTimerAnimation, 100); }
            else { timerContainer.classList.remove('hide-during-intro'); updateTimerDisplay(); }
            detectTouch();
        }

        function startTimerAnimation() {
            if (!enableTimeBomb || enableBlind || timeLimitMilliseconds <= 0) { return; }
            const includeHours = timeLimitMilliseconds >= 3600000;
            timerStartDisplay.textContent = formatMsToDisplayTime(timeLimitMilliseconds, includeHours);
            timerStartDisplay.style.animation = 'start-blink 1s infinite';
            timerStartDisplay.classList.add('visible');
            body.classList.add('timer-intro-active');
            setTimeout(() => { if (body.classList.contains('timer-intro-active')) { timerStartDisplay.classList.add('move-to-corner'); } }, 1200);
            setTimeout(() => {
                if (body.classList.contains('timer-intro-active')) {
                    timerStartDisplay.classList.remove('visible', 'move-to-corner');
                    timerStartDisplay.style.animation = 'none';
                    timerContainer.classList.remove('hide-during-intro');
                    body.classList.remove('timer-intro-active');
                    updateTimerDisplay();
                }
            }, 1600);
        }

        function plantMines() {
             let minesPlanted = 0; const maxPossible = gridSize * gridSize; let currentNumMines = numMines;
             if (currentNumMines >= maxPossible) { currentNumMines = maxPossible - 1; console.warn(`Mine count capped at ${currentNumMines}`); if (!enableBlind) { mineSlider.value = currentNumMines; mineCountDisplay.textContent = currentNumMines; pendingSettings.numMines = currentNumMines; } numMines = currentNumMines; }
             if (currentNumMines < 0) { currentNumMines = 0; if (!enableBlind) { mineSlider.value = currentNumMines; mineCountDisplay.textContent = currentNumMines; pendingSettings.numMines = currentNumMines; } numMines = currentNumMines; }
             minesLeft = currentNumMines;
             while (minesPlanted < currentNumMines) {
                  const r = Math.floor(Math.random() * gridSize); const c = Math.floor(Math.random() * gridSize);
                  if (!board[r][c].isMine) { board[r][c].isMine = true; minesPlanted++; }
             }
        }

        function calculateAdjacentMines() {
             const isTorus = enableBlind && activeBlindRule?.id === 'torus';
             for (let i = 0; i < gridSize; i++) {
                  for (let j = 0; j < gridSize; j++) {
                       if (board[i][j].isMine) { board[i][j].adjacentMines = -1; board[i][j].originalAdjacentMines = -1; board[i][j].adjacentSafe = -1; continue; }
                       let mineCount = 0; let safeCount = 0;
                       for (let x = -1; x <= 1; x++) {
                            for (let y = -1; y <= 1; y++) {
                                 if (x === 0 && y === 0) continue;
                                 let ni = i + x; let nj = j + y; let isValidNeighbor = false;
                                 if (isTorus) { ni = (ni + gridSize) % gridSize; nj = (nj + gridSize) % gridSize; isValidNeighbor = true; }
                                 else { isValidNeighbor = ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize; }
                                 if (isValidNeighbor) { if (board[ni][nj]?.isMine) { mineCount++; } else { safeCount++; } }
                            }
                       }
                       board[i][j].originalAdjacentMines = mineCount;
                       board[i][j].adjacentSafe = safeCount;
                       board[i][j].adjacentMines = mineCount; // Initialize with mine count
                       board[i][j].isAdjusted = false;
                  }
             }
        }

        function countSafeInDirection(r, c, dx, dy) {
             const isTorus = enableBlind && activeBlindRule?.id === 'torus'; let count = 0; let cr = r + dx; let cc = c + dy;
             let steps = 0; const maxSteps = gridSize * 2;
             while (steps < maxSteps) {
                 let checkR = cr; let checkC = cc; let inBounds = false;
                 if (isTorus) { checkR = (cr + gridSize) % gridSize; checkC = (cc + gridSize) % gridSize; if (steps > 0 && checkR === r && checkC === c) break; inBounds = true; }
                 else { inBounds = checkR >= 0 && checkR < gridSize && checkC >= 0 && checkC < gridSize; }
                 if (!inBounds) break;
                 if (!board[checkR][checkC]?.isMine) count++;
                 cr += dx; cc += dy; steps++;
             }
             return count;
        }

        function countMinesInDirection(r, c, dx, dy) {
             const isTorus = enableBlind && activeBlindRule?.id === 'torus'; let count = 0; let cr = r + dx; let cc = c + dy;
             let steps = 0; const maxSteps = gridSize * 2;
             while (steps < maxSteps) {
                 let checkR = cr; let checkC = cc; let inBounds = false;
                 if (isTorus) { checkR = (cr + gridSize) % gridSize; checkC = (cc + gridSize) % gridSize; if (steps > 0 && checkR === r && checkC === c) break; inBounds = true; }
                 else { inBounds = checkR >= 0 && checkR < gridSize && checkC >= 0 && checkC < gridSize; }
                 if (!inBounds) break;
                 if (board[checkR][checkC]?.isMine) count++;
                 cr += dx; cc += dy; steps++;
             }
             return count;
        }

        function hasNeighborOfType(r, c, key) {
             const isTorus = enableBlind && activeBlindRule?.id === 'torus';
             for (let x = -1; x <= 1; x++) {
                  for (let y = -1; y <= 1; y++) {
                       if (x === 0 && y === 0) continue;
                       let ni = r + x;
                       // *** 修正 *** : j を c に修正
                       let nj = c + y;
                       if (isTorus) {
                           ni = (ni + gridSize) % gridSize;
                           nj = (nj + gridSize) % gridSize;
                           // nullish coalescing operator で board[ni] が存在しない場合も考慮
                           if (board[ni]?.[nj]?.[key]) return true;
                       } else {
                           if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize && board[ni]?.[nj]?.[key]) return true;
                       }
                  }
             }
             return false;
        }

        function calculateNaturalNumberValue(n) {
             if (n < 0) n = 0; const p = [2, 3, 5, 7]; if (p.includes(n)) return n.toString();
             switch (n) {
                  case 0: return "?"; case 1: return "-1"; case 4: return "±1"; case 6: return "±1"; case 8: return "+1"; default: return "?";
             }
        }

        function applySpecialSquares() {
            const potentialSquares = []; const errorTargetSquares = []; const isAbekobe = enableBlind && activeBlindRule?.id === 'abekobe';

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const square = board[i][j];
                    square.isHide = square.isOddEven = square.isAreaValue = square.isDirectional = square.isNaturalNumber = false;
                    square.oddEvenValue = square.areaValue = square.direction = square.directionalCount = square.directionalSymbol = square.naturalNumberValue = null;
                    square.isAdjusted = false;
                    // Apply Abekobe base value first
                    square.adjacentMines = isAbekobe ? square.adjacentSafe : square.originalAdjacentMines;
                    const relevantCount = square.adjacentMines;

                    if (!square.isMine && relevantCount > 0) { potentialSquares.push({ r: i, c: j }); }
                    if (!square.isMine && square.originalAdjacentMines > 0) { errorTargetSquares.push({ r: i, c: j}); }
                }
            }
            potentialSquares.sort(() => Math.random() - 0.5); errorTargetSquares.sort(() => Math.random() - 0.5);

            const assignedCoordinates = new Set(); const numPotential = potentialSquares.length;
            const isBlindAnomaly = enableBlind && activeBlindRule?.id === 'anomaly';

             let rateHide = currentMaxHideRate; let rateDirectional = currentMaxDirectionalRate; let rateOddEven = currentMaxOddEvenRate;
             let rateAreaValue = currentMaxAreaValueRate; let rateNaturalNumber = currentMaxNaturalNumberRate;
             if (isBlindAnomaly && anomalyTargetType) {
                 switch(anomalyTargetType) {
                     case 'hide': rateHide = currentAnomalyRate; break; case 'directional': rateDirectional = currentAnomalyRate; break;
                     case 'oddEven': rateOddEven = currentAnomalyRate; break; case 'areaValue': rateAreaValue = currentAnomalyRate; break;
                     case 'naturalNumber': rateNaturalNumber = currentAnomalyRate; break;
                 }
             }

            const baseDirections = [ { dx: -1, dy: 0, s: 'T', n: 'up' }, { dx: 1, dy: 0, s: 'B', n: 'down' }, { dx: 0, dy: -1, s: 'L', n: 'left' }, { dx: 0, dy: 1, s: 'R', n: 'right' } ];
            function hasDirChain(r, c, dx, dy) { /* ... */ } // Implementation unchanged
            function getValidDirs(r, c) { return baseDirections.filter(dir => { const nr = r + dir.dx; const nc = c + dir.dy; const isTorus = enableBlind && activeBlindRule?.id === 'torus'; if(isTorus) return true; return nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize; }); }

            const ruleOrder = [
                { t: 'areaValue', e: enableAreaValue, r: rateAreaValue, c: (s, r, c) => !hasNeighborOfType(r, c, 'isAreaValue') },
                { t: 'naturalNumber', e: enableNaturalNumber, r: rateNaturalNumber, c: (s, r, c) => !hasNeighborOfType(r, c, 'isNaturalNumber') },
                { t: 'directional', e: enableDirectional, r: rateDirectional, c: (s, r, c) => !hasNeighborOfType(r, c, 'isDirectional') },
                { t: 'oddEven', e: enableOddEven, r: rateOddEven, c: (s, r, c) => s.originalAdjacentMines > 1 && !hasNeighborOfType(r, c, 'isOddEven') },
                { t: 'hide', e: enableHide, r: rateHide, c: () => true }
            ];

            for (const rule of ruleOrder) {
                 const ruleEnabled = enableBlind || rule.e;
                if (ruleEnabled && numPotential > 0) {
                    const maxCount = Math.floor(numPotential * rule.r); let currentCount = 0;
                    for (const { r, c } of potentialSquares) {
                        if (currentCount >= maxCount) break;
                        const coordKey = `${r}-${c}`; const square = board[r][c];
                        const oddEvenConstraintCheck = (rule.t !== 'oddEven') || (square.originalAdjacentMines > 1 && !hasNeighborOfType(r, c, 'isOddEven'));
                        // Blind mode ignores neighbor checks for most types except OddEven's specific mine count check
                        const neighborCheckRequired = !enableBlind && !['hide', 'oddEven'].includes(rule.t);
                        const neighborCheckPassed = !neighborCheckRequired || rule.c(square, r, c);


                        if (!assignedCoordinates.has(coordKey) && neighborCheckPassed && oddEvenConstraintCheck) {
                             const countForCalc = square.adjacentMines;
                            let applied = false;
                            if (rule.t === 'directional') {
                                 const validDirs = getValidDirs(r, c);
                                 if (validDirs.length > 0) {
                                     const shuffledDirs = [...validDirs].sort(() => Math.random() - 0.5);
                                     for (const dir of shuffledDirs) {
                                         const skipChainCheck = enableBlind && activeBlindRule?.id === 'torus';
                                         if (skipChainCheck || !hasDirChain(r, c, dir.dx, dir.dy)) {
                                             const dirCount = isAbekobe ? countSafeInDirection(r, c, dir.dx, dir.dy) : countMinesInDirection(r, c, dir.dx, dir.dy);
                                             square.isDirectional = true; square.isHide = true; square.direction = { dx: dir.dx, dy: dir.dy, name: dir.n };
                                             square.directionalCount = dirCount; square.directionalSymbol = dir.s; applied = true; break;
                                         }
                                     }
                                 }
                            } else if (rule.t === 'areaValue') {
                                square.isAreaValue = true; square.isHide = true;
                                if (countForCalc <= 3) square.areaValue = '~3'; else if (countForCalc <= 6) square.areaValue = '4~6'; else square.areaValue = '7~';
                                applied = true;
                            } else if (rule.t === 'oddEven') {
                                square.isOddEven = true; square.isHide = true;
                                square.oddEvenValue = countForCalc % 2 === 0 ? 'Ev' : 'Od';
                                applied = true;
                            } else if (rule.t === 'naturalNumber') {
                                square.isNaturalNumber = true; square.isHide = true;
                                square.naturalNumberValue = calculateNaturalNumberValue(countForCalc);
                                applied = true;
                            } else if (rule.t === 'hide') { square.isHide = true; applied = true; }
                            if (applied) { assignedCoordinates.add(coordKey); currentCount++; }
                        }
                    }
                }
            }

            // --- Apply 'Error' Rule ---
            if (enableBlind && activeBlindRule?.id === 'error') {
                 const numErrorTargets = errorTargetSquares.length; const minAffectedCount = Math.ceil(numErrorTargets * MIN_ERROR_RATE); let affectedCount = 0;
                 for(let i = 0; i < numErrorTargets && affectedCount < minAffectedCount; i++) {
                     const { r, c } = errorTargetSquares[i]; const square = board[r][c]; const coordKey = `${r}-${c}`;
                     if (!assignedCoordinates.has(coordKey) && !square.isAdjusted) {
                         const adjustUp = Math.random() < 0.5; if (adjustUp) { square.adjacentMines++; } else { square.adjacentMines = Math.max(0, square.adjacentMines - 1); }
                         square.isAdjusted = true; affectedCount++;
                     }
                 }
                 for(let i = affectedCount; i < numErrorTargets; i++) {
                     const { r, c } = errorTargetSquares[i]; const square = board[r][c]; const coordKey = `${r}-${c}`;
                      if (!assignedCoordinates.has(coordKey) && !square.isAdjusted) {
                         const rand = Math.random();
                         if (rand < 0.25) { square.adjacentMines++; square.isAdjusted = true; }
                         else if (rand < 0.50) { square.adjacentMines = Math.max(0, square.adjacentMines - 1); square.isAdjusted = true; }
                     }
                 }
            }
        }

        // --- Interaction and Rendering Functions ---
        function handleSquareInteraction(r, c) {
            if (gameOver || board[r][c].isRevealed || justFlagged) { return; }
            if (!gameStarted) { startGameTimer(); }
            const square = board[r][c];

            if (currentInteractionMode === 'flag') { if (!enableNoFlags) { handleFlagAction(r, c); } }
            else {
                if (square.isFlagged && !enableNoFlags) { return; }
                if (square.isMine) {
                    if (!square.isRevealed) {
                        revealMine(r, c); clickedMineCount++;
                         if (enableTimeBomb && !enableBlind && gameOverOnTimeOnly) {
                            penaltyOffsetMs += MINE_PENALTY_MS; const wasLowTime = body.classList.contains('low-time');
                             body.style.transition = 'background-color 0.1s ease-out'; body.style.backgroundColor = '#ffdddd';
                             setTimeout(() => { body.style.transition = 'background-color 0.5s ease'; body.style.backgroundColor = ''; const currentRemainingAfterPenalty = timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs; body.classList.toggle('low-time', currentRemainingAfterPenalty < 60000 && currentRemainingAfterPenalty > 0); updateTimerDisplay(); }, 150);
                             setTimeout(() => { const currentRemaining = timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs; if ((clickedMineCount >= numMines || currentRemaining <= 0) && !gameOver) { endGame(false); } }, timerUpdateInterval + 10);
                        } else { endGame(false); }
                    }
                } else { revealSquare(r, c); checkWinCondition(); }
            }
        }

        function startGameTimer() {
            if (gameStarted) { return; }
            gameStarted = true; startTime = Date.now(); penaltyOffsetMs = 0;
            if (enableTimeBomb && !enableBlind) { remainingMilliseconds = timeLimitMilliseconds; } else { elapsedMilliseconds = 0; }
            if (timerInterval) { clearInterval(timerInterval); } timerInterval = setInterval(updateTimer, timerUpdateInterval);
             if (enableBlind && activeBlindRule?.id === 'basketball') {
                 basketballStartTime = Date.now(); basketballRemainingMs = BASKETBALL_INTERVAL_MS;
                 if (basketballTimerInterval) { clearInterval(basketballTimerInterval); }
                 basketballTimerInterval = setInterval(updateBasketballTimer, timerUpdateInterval);
                 timerContainer.classList.add('blinking-basketball');
             }
            updateTimerDisplay();
        }

         function resetBasketballTimer() {
             if (enableBlind && activeBlindRule?.id === 'basketball' && gameStarted && !gameOver) {
                 basketballStartTime = Date.now(); basketballRemainingMs = BASKETBALL_INTERVAL_MS;
                 timerContainer.classList.add('blinking-basketball'); updateTimerDisplay();
             }
         }

        function handleFlagAction(r, c) {
            if (enableNoFlags || gameOver || board[r][c].isRevealed) { return; }
            if (!gameStarted) { startGameTimer(); }
            // Flagging does not reset basketball timer
            const sq = board[r][c]; sq.isFlagged = !sq.isFlagged;
            if (sq.isFlagged) { minesLeft--; } else { minesLeft++; }
            renderSquareContent(sq); updateMinesLeftDisplay();
        }

        function revealMine(r, c) {
            const sq = board[r][c]; sq.isRevealed = true;
            sq.element.classList.add('mine-clicked'); renderSquareContent(sq);
        }

        function revealSquare(r, c) {
             const isTorus = enableBlind && activeBlindRule?.id === 'torus'; let checkR = r; let checkC = c;
             if (isTorus) { checkR = (r + gridSize) % gridSize; checkC = (c + gridSize) % gridSize; }
             if (checkR < 0 || checkR >= gridSize || checkC < 0 || checkC >= gridSize || gameOver) { return; }
            const sq = board[checkR][checkC];
            if (sq.isRevealed || sq.isMine || (sq.isFlagged && !enableNoFlags)) { return; }

            sq.isRevealed = true; revealedNonMineCount++;
            resetBasketballTimer(); // Reset timer ONLY when revealing a safe square
            renderSquareContent(sq);

            const canChain = !(enableBlind && activeBlindRule?.id === 'noChain');
            if (sq.originalAdjacentMines === 0 && canChain && !sq.isDirectional && !sq.isAreaValue && !sq.isOddEven && !sq.isNaturalNumber && !sq.isHide) {
                for (let x = -1; x <= 1; x++) { for (let y = -1; y <= 1; y++) { if (x !== 0 || y !== 0) { revealSquare(checkR + x, checkC + y); } } }
            }
        }

        function renderSquareContent(sq) {
            const el = sq.element; const keepClasses = ['mine-clicked', 'flag-wrong'].filter(cls => el.classList.contains(cls));
            el.className = 'square'; keepClasses.forEach(cls => el.classList.add(cls));
            el.textContent = ''; el.innerHTML = ''; el.style.fontSize = ''; el.style.lineHeight = ''; el.classList.remove('number-adjusted');

            if (!sq.isRevealed) {
                el.classList.add('hidden'); const flagsAllowed = !enableNoFlags;
                if (sq.isFlagged && flagsAllowed) { el.textContent = '🚩'; el.classList.add('flagged'); }
            } else {
                el.classList.add('revealed');
                if (sq.isMine) { el.classList.add('mine'); el.textContent = el.classList.contains('mine-clicked') ? '💥' : '💣'; }
                else {
                    if (el.classList.contains('flag-wrong')) { el.textContent = '❌'; }
                    else if (sq.isDirectional) { el.classList.add('directional-square', 'special-square'); el.textContent = sq.directionalSymbol + sq.directionalCount; }
                    else if (sq.isAreaValue) { el.classList.add('area-value-square', 'special-square'); if (sq.areaValue === '4~6') { el.innerHTML = '4~<br>6'; el.style.lineHeight = '0.9'; el.style.fontSize = '9px'; } else { el.textContent = sq.areaValue; } }
                    else if (sq.isOddEven) { el.classList.add('odd-even-square', 'special-square'); el.textContent = sq.oddEvenValue; }
                    else if (sq.isNaturalNumber) { el.classList.add('natural-number-square', 'special-square'); if (sq.naturalNumberValue === '±1') { el.style.fontSize = '10px'; } el.textContent = sq.naturalNumberValue; }
                    else if (sq.isHide) { el.classList.add('special-square'); el.textContent = '・'; }
                    else if (sq.adjacentMines >= 0) {
                        el.textContent = sq.adjacentMines > 0 ? sq.adjacentMines : '';
                        if (sq.adjacentMines > 0) { el.classList.add(`number-${sq.adjacentMines}`); }
                        if (sq.isAdjusted && activeBlindRule?.id === 'error') { el.classList.add('number-adjusted'); }
                    } else { el.textContent = ''; el.classList.add('revealed'); }
                }
            }
        }

        function updateMinesLeftDisplay() {
            const flagsEnabled = !enableNoFlags; // Flags enabled if NoFlags mode is OFF
            // console.log("updateMinesLeftDisplay called. flagsEnabled:", flagsEnabled, "enableNoFlags:", enableNoFlags, "enableBlind:", enableBlind, "minesLeft:", minesLeft);
            messageBox.textContent = flagsEnabled ? `Mines: ${minesLeft}` : '';
        }

        function checkWinCondition() {
            if (gameOver) { return; }
            const totalNonMineSquares = gridSize * gridSize - numMines;
            if (revealedNonMineCount >= totalNonMineSquares) {
                let allSafeRevealed = true;
                for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) { if (!board[i][j].isMine && !board[i][j].isRevealed) { allSafeRevealed = false; break; } } if (!allSafeRevealed) break; }
                if (allSafeRevealed) {
                     if (enableTimeBomb && !enableBlind && remainingMilliseconds <= 0 && gameStarted) { return; }
                     if (enableBlind && activeBlindRule?.id === 'basketball' && basketballRemainingMs <= 0 && gameStarted) { return; }
                    endGame(true);
                }
            }
        }

        function endGame(isWin) {
            if (gameOver) { return; } gameOver = true; clearInterval(timerInterval); timerInterval = null; clearInterval(basketballTimerInterval); basketballTimerInterval = null;
            body.classList.remove('low-time', 'timer-intro-active'); timerContainer.classList.remove('blinking-black', 'blinking-red', 'blinking-basketball');
            let finalDisplayMillis = 0;
            if (gameStarted) { if (enableBlind || !enableTimeBomb) { elapsedMilliseconds = Date.now() - startTime; finalDisplayMillis = elapsedMilliseconds; } else { remainingMilliseconds = Math.max(0, timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs); finalDisplayMillis = remainingMilliseconds; } }

            if (isWin) {
                messageBox.textContent = 'Game Clear!'; body.style.backgroundColor = '#aaffaa';
                const flagsAllowed = !enableNoFlags;
                if (flagsAllowed) { for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) { if (board[i][j].isMine && !board[i][j].isFlagged) { board[i][j].isFlagged = true; renderSquareContent(board[i][j]); } } } minesLeft = 0; updateMinesLeftDisplay(); }
                 if (gameStarted) {
                       if (enableTimeBomb && !enableBlind) {
                           const h = Math.floor(finalDisplayMillis / 3600000); const m = Math.floor((finalDisplayMillis % 3600000) / 60000); const s = Math.floor((finalDisplayMillis % 60000) / 1000); const cs = Math.floor((finalDisplayMillis % 1000) / 10);
                           if (finalDisplayMillis < 3600000) { timerSpan.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`; }
                           else { timerSpan.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }
                      } else { updateTimerDisplay(); }
                 } else { timerSpan.textContent = (enableTimeBomb && !enableBlind) ? formatMsToDisplayTime(timeLimitMilliseconds, true) : '00.00'; }
            } else {
                if (messageBox.textContent !== 'Game Clear!') {
                    if (enableBlind && activeBlindRule?.id === 'basketball' && basketballRemainingMs <= 0 && gameStarted) { messageBox.textContent = 'Time Up!'; }
                    else if (enableTimeBomb && !enableBlind && gameOverOnTimeOnly && clickedMineCount >= numMines) { messageBox.textContent = 'All Mines Hit!'; }
                    else if (enableTimeBomb && !enableBlind && remainingMilliseconds <= 0 && gameStarted) { messageBox.textContent = 'Time Up!'; }
                    else { messageBox.textContent = 'Game Over!'; }
                }
                body.classList.add('game-over'); revealAllMines(true); updateTimerDisplay();
            }
        }

        function revealAllMines(showIncorrectFlags) {
             const flagsAllowed = !enableNoFlags;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const sq = board[i][j]; const el = sq.element;
                    if (sq.isMine) { if ((sq.isFlagged && flagsAllowed) || el.classList.contains('mine-clicked')) { continue; } sq.isRevealed = true; renderSquareContent(sq); }
                    else { if (showIncorrectFlags && sq.isFlagged && flagsAllowed) { sq.isRevealed = true; el.className = 'square revealed flag-wrong'; el.textContent = '❌'; } else if (showIncorrectFlags && !sq.isRevealed && document.activeElement === revealAllButton) { revealSquare(i, j); } }
                }
            }
        }

        // --- Timer Functions ---
        function updateTimer() {
            if (!gameStarted || gameOver) { if (timerInterval && gameOver) { clearInterval(timerInterval); timerInterval = null; } return; }
            if (enableTimeBomb && !enableBlind) {
                const elapsed = Date.now() - startTime; remainingMilliseconds = timeLimitMilliseconds - elapsed - penaltyOffsetMs;
                if (remainingMilliseconds <= 0) { remainingMilliseconds = 0; updateTimerDisplay(); clearInterval(timerInterval); timerInterval = null; if (!gameOver) { endGame(false); } }
                else { updateTimerDisplay(); }
            } else { elapsedMilliseconds = Date.now() - startTime; updateTimerDisplay(); }
        }

         function updateBasketballTimer() {
             if (!gameStarted || gameOver || !enableBlind || activeBlindRule?.id !== 'basketball') { if (basketballTimerInterval) { clearInterval(basketballTimerInterval); basketballTimerInterval = null; } return; }
             const elapsedBasketball = Date.now() - basketballStartTime; basketballRemainingMs = BASKETBALL_INTERVAL_MS - elapsedBasketball;
             if (basketballRemainingMs <= 0) { basketballRemainingMs = 0; updateTimerDisplay(); clearInterval(basketballTimerInterval); basketballTimerInterval = null; if (!gameOver) { endGame(false); } }
             else { updateTimerDisplay(); timerContainer.classList.toggle('blinking-basketball', basketballRemainingMs <= 3000); }
         }

        function updateTimerDisplay() {
            if (gameOver && enableTimeBomb && !enableBlind && messageBox.textContent === 'Game Clear!') { return; }
            let formattedTime; let displayMillis;

            if (enableBlind && activeBlindRule?.id === 'basketball' && gameStarted && !gameOver) { displayMillis = basketballRemainingMs; timerContainer.classList.remove('blinking-black', 'blinking-red'); }
            else if (enableTimeBomb && !enableBlind) {
                displayMillis = remainingMilliseconds; timerContainer.classList.remove('blinking-basketball');
                if (gameStarted && !gameOver) { const isLowTime = displayMillis < 60000 && displayMillis > 0; timerContainer.classList.toggle('blinking-red', isLowTime); timerContainer.classList.toggle('blinking-black', !isLowTime && displayMillis > 0); body.classList.toggle('low-time', isLowTime); }
                else { timerContainer.classList.remove('blinking-red', 'blinking-black'); body.classList.remove('low-time'); }
            } else {
                 displayMillis = elapsedMilliseconds;
                 if (gameOver && messageBox.textContent !== 'Game Clear!') { if (enableTimeBomb && !enableBlind) { displayMillis = remainingMilliseconds; } else { displayMillis = elapsedMilliseconds; } }
                 else if (gameOver && messageBox.textContent === 'Game Clear!' && (enableBlind || !enableTimeBomb)) { displayMillis = elapsedMilliseconds; }
                 timerContainer.classList.remove('blinking-red', 'blinking-black', 'blinking-basketball'); body.classList.remove('low-time');
            }
            const safeMillis = Math.max(0, displayMillis);

             if (enableBlind && activeBlindRule?.id === 'basketball' && gameStarted && !gameOver) { const s = Math.floor(safeMillis / 1000); const cs = Math.floor((safeMillis % 1000) / 10); formattedTime = `${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`; }
             else if (safeMillis < 60000) { const s = Math.floor(safeMillis / 1000); const cs = Math.floor((safeMillis % 1000) / 10); formattedTime = `${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`; }
             else if (safeMillis < 3600000) { const m = Math.floor(safeMillis / 60000); const s = Math.floor((safeMillis % 60000) / 1000); formattedTime = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; }
             else { const h = Math.floor(safeMillis / 3600000); const m = Math.floor((safeMillis % 3600000) / 60000); const s = Math.floor((safeMillis % 60000) / 1000); formattedTime = `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; }
            timerSpan.textContent = formattedTime;
        }

        // --- Debug Functions ---
        function revealNonMines() {
            if (gameOver) { return; } if (!gameStarted) { startGameTimer(); }
            for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) { if (!board[i][j].isMine && !board[i][j].isRevealed) { revealSquare(i, j); } } }
            checkWinCondition(); if (!gameOver) { endGame(true); }
            messageBox.textContent = 'All non-mines revealed!';
        }

        function revealAll() {
            if (gameOver) { return; } if (!gameStarted) { startGameTimer(); }
            revealAllMines(true); if (!gameOver) { endGame(false); }
            messageBox.textContent = 'All squares revealed!';
        }

        // --- Initial Setup ---
        updateTimerDisplay(); updateActiveRulesDisplay(); updateNoFlagsUI(); detectTouch(); createBoard();

    </script>
</body>
</html>
