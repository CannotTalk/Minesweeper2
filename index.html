<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>マインスイーパー</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Use min-height to avoid issues on small screens */
            margin: 0;
            padding: 10px 0; /* Add some padding */
            background-color: #f0f0f0;
            font-family: 'Press Start 2P', cursive;
            transition: background-color 0.5s ease;
        }
        body.game-over {
            background-color: #ff4444;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 12px; /* Reduced margin */
        }
        #board {
            display: grid;
            /* Adjusted grid size based on number of columns */
            grid-template-columns: repeat(15, 20px); /* Smaller squares (20px) */
            border: 2px solid #333;
            background-color: #b4c687;
            padding: 4px; /* Reduced padding */
        }
        .square {
            width: 20px;  /* Smaller width */
            height: 20px; /* Smaller height */
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 11px; /* Smaller font size */
            user-select: none;
            background-color: #eee;
            line-height: 1; /* Adjust line height for better centering */
        }
        .hidden {
            background-color: #ddd;
        }
        .revealed {
            background-color: #b4c687;
        }
        .mine {
            background-color: #ff4444;
            color: #fff;
            font-size: 12px; /* Slightly larger for bomb icon */
        }
        #reset-button {
            padding: 6px 12px; /* Smaller button padding */
            font-size: 12px; /* Smaller font size */
            cursor: pointer;
            margin-top: 8px; /* Reduced margin */
            font-family: 'Press Start 2P', cursive;
        }
        #message-box {
            margin-top: 8px; /* Reduced margin */
            font-size: 12px; /* Smaller font size */
            color: #333;
            margin-bottom: 8px; /* Reduced margin */
            height: 14px; /* Give it a fixed height to avoid layout shifts */
        }
        .timer {
            font-size: 14px; /* Smaller font size */
            margin-top: 8px; /* Reduced margin */
            color: #333;
        }
        /* Removed .direction class as it wasn't used */

        .settings-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-top: 12px; /* Reduced margin */
            padding: 8px; /* Reduced padding */
            border: 2px solid #333;
            border-radius: 5px;
            background-color: #fff;
        }

        .setting-label {
            display: flex;
            align-items: center;
            margin-bottom: 4px; /* Reduced margin */
            font-size: 10px; /* Smaller font size */
        }
        .setting-label:last-child {
            margin-bottom: 0; /* Remove margin for the last item */
        }


        .switch {
            position: relative;
            display: inline-block;
            width: 34px; /* Smaller switch width */
            height: 18px; /* Smaller switch height */
            margin-left: 6px; /* Reduced margin */
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 18px; /* Adjusted for smaller size */
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 10px; /* Smaller slider handle height */
            width: 10px; /* Smaller slider handle width */
            left: 4px; /* Adjusted */
            bottom: 4px; /* Adjusted */
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(16px); /* Adjusted for smaller size */
            -ms-transform: translateX(16px);
            transform: translateX(16px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 18px; /* Adjusted for smaller size */
        }

        .slider.round:before {
            border-radius: 50%;
        }
        .special-square {
            font-size: 9px; /* Smaller font size */
        }
        .odd-even-square {
            color: #ccae00; /* Adjusted color slightly for visibility */
            font-weight: bold;
        }

        .area-value-square{
            color: #902094; /* Adjusted color slightly for visibility */
            font-weight: bold;
        }
        #debug-buttons {
            display: flex;
            margin-top: 8px; /* Reduced margin */
        }
        #debug-buttons button {
            margin-left: 4px; /* Reduced left margin */
            padding: 6px 10px; /* Smaller button padding */
            font-size: 10px; /* Smaller font size */
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
        }
        #debug-buttons button:first-child {
            margin-left: 0; /* Remove margin for the first button */
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="board"></div>
        <div class="timer">Time: <span id="timer">0:00:00</span></div>
        <div id="message-box"></div>
        <button id="reset-button">Reset</button>
        <div class="settings-container">
            <div class="setting-label">
                ハイドマス
                <label class="switch">
                    <input type="checkbox" id="hide-switch" checked>
                    <span class="slider round"></span>
                </label>
            </div>
            <div class="setting-label">
                オッドオアイーブンマス
                <label class="switch">
                    <input type="checkbox" id="odd-even-switch" checked>
                    <span class="slider round"></span>
                </label>
            </div>
            <div class="setting-label">
                エリアバリューマス
                <label class="switch">
                    <input type="checkbox" id="area-value-switch" checked>
                    <span class="slider round"></span>
                </label>
            </div>
        </div>
        <div id="debug-buttons">
            <button id="reveal-non-mines">Open Non-Mines</button> <!-- Shortened Text -->
            <button id="reveal-all">Open All</button>
        </div>
    </div>
    <script>
        const gridSize = 15;
        const numMines = 30;
        const maxHideRate = 0.15;
        const minHideRate = 0;
        const maxOddEvenRate = 0.05;
        const maxAreaValueRate = 0.10;

        let board = [];
        let minesLeft = numMines;
        let gameOver = false;
        // hiddenCount is not used for win condition anymore, removing it
        let timerInterval;
        let seconds = 0;
        let revealedNonMineCount = 0; // Track revealed non-mine squares for win condition
        let gameStarted = false; // To start timer on first click

        let enableHide = true;
        let enableOddEven = true;
        let enableAreaValue = true;

        let boardElement = document.getElementById('board');
        const resetButton = document.getElementById('reset-button');
        const messageBox = document.getElementById('message-box');
        const timerDisplay = document.getElementById('timer');
        const body = document.body;

        const hideSwitch = document.getElementById('hide-switch');
        const oddEvenSwitch = document.getElementById('odd-even-switch');
        const areaValueSwitch = document.getElementById('area-value-switch');
        const revealNonMinesButton = document.getElementById('reveal-non-mines');
        const revealAllButton = document.getElementById('reveal-all');

        hideSwitch.addEventListener('change', () => {
            enableHide = hideSwitch.checked;
            resetGame(); // Reset when settings change
        });
        oddEvenSwitch.addEventListener('change', () => {
            enableOddEven = oddEvenSwitch.checked;
            resetGame(); // Reset when settings change
        });
        areaValueSwitch.addEventListener('change', () => {
            enableAreaValue = areaValueSwitch.checked;
            resetGame(); // Reset when settings change
        });

        resetButton.addEventListener('click', resetGame);
        revealNonMinesButton.addEventListener('click', revealNonMines);
        revealAllButton.addEventListener('click', revealAll);

        function resetGame() {
            gameOver = true; // Prevent clicks during reset
            clearInterval(timerInterval);
            seconds = 0;
            updateTimerDisplay();
            gameStarted = false;
            messageBox.textContent = ''; // Clear message immediately
            body.classList.remove('game-over');
            body.style.backgroundColor = '#f0f0f0'; // Reset background immediately
            // Delay board creation slightly to allow UI updates
            setTimeout(createBoard, 50);
        }

        function createBoard() {
            board = [];
            minesLeft = numMines;
            gameOver = false;
            revealedNonMineCount = 0; // Reset revealed count
            boardElement.innerHTML = ''; // Clear previous board elements

            // Calculate total non-mine squares needed for win
            const totalNonMineSquares = gridSize * gridSize - numMines;

            for (let i = 0; i < gridSize; i++) {
                board[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    board[i][j] = {
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        isHide: false,
                        isOddEven: false,
                        isAreaValue: false,
                        oddEvenValue: null,
                        areaValue: null,
                        adjacentMines: 0,
                        element: document.createElement('div')
                    };
                    const squareElement = board[i][j].element;
                    squareElement.classList.add('square');
                    squareElement.classList.add('hidden');
                    // Add dataset attributes for easier debugging if needed
                    squareElement.dataset.row = i;
                    squareElement.dataset.col = j;
                    squareElement.addEventListener('click', () => handleSquareClick(i, j));
                    squareElement.addEventListener('contextmenu', (event) => {
                        event.preventDefault();
                        handleRightClick(i, j);
                    });
                    boardElement.appendChild(squareElement);
                }
            }
            plantMines();
            calculateAdjacentMines();
            // Apply special squares *after* adjacent mines are calculated
            applySpecialSquares();
            updateMinesLeftDisplay(); // Initial display
        }

        function plantMines() {
            let minesPlanted = 0;
            while (minesPlanted < numMines) {
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                if (!board[row][col].isMine) {
                    board[row][col].isMine = true;
                    minesPlanted++;
                }
            }
        }

        function calculateAdjacentMines() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (board[i][j].isMine) {
                        board[i][j].adjacentMines = -1; // Mark mines internally
                        continue;
                    }
                    let count = 0;
                    for (let x = -1; x <= 1; x++) {
                        for (let y = -1; y <= 1; y++) {
                            if (x === 0 && y === 0) continue;
                            const ni = i + x;
                            const nj = j + y;
                            if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize && board[ni][nj].isMine) {
                                count++;
                            }
                        }
                    }
                    board[i][j].adjacentMines = count;
                }
            }
        }

       function applySpecialSquares() {
            const potentialSquares = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    // Only non-mine squares with adjacent mines > 0 are candidates
                    if (!board[i][j].isMine && board[i][j].adjacentMines > 0) {
                        potentialSquares.push({ row: i, col: j });
                    }
                }
            }

            // Shuffle potential squares for random distribution
            potentialSquares.sort(() => Math.random() - 0.5);

            const totalSquares = gridSize * gridSize;
            let appliedCount = 0;

            // Apply Area Value first (higher priority if enabled)
            if (enableAreaValue) {
                const maxArea = Math.floor(totalSquares * maxAreaValueRate);
                appliedCount = 0;
                for (let k = 0; k < potentialSquares.length && appliedCount < maxArea; k++) {
                    const { row, col } = potentialSquares[k];
                    // Check if already assigned and if neighbors are not AreaValue
                    if (!board[row][col].isHide && !board[row][col].isOddEven && !hasNeighborOfType(row, col, 'isAreaValue')) {
                         board[row][col].isAreaValue = true;
                         board[row][col].isHide = true; // AreaValue implies Hide
                         if (board[row][col].adjacentMines <= 3) {
                             board[row][col].areaValue = '-3';
                         } else if (board[row][col].adjacentMines <= 6) {
                             board[row][col].areaValue = '4-6';
                         } else {
                             board[row][col].areaValue = '7+';
                         }
                         appliedCount++;
                    }
                }
            }

             // Apply Odd/Even next
            if (enableOddEven) {
                const maxOddEven = Math.floor(totalSquares * maxOddEvenRate);
                appliedCount = 0;
                 for (let k = 0; k < potentialSquares.length && appliedCount < maxOddEven; k++) {
                    const { row, col } = potentialSquares[k];
                     // Check if already assigned, requires > 1 adjacent mine, and neighbors are not OddEven
                    if (!board[row][col].isHide && !board[row][col].isAreaValue && board[row][col].adjacentMines > 1 && !hasNeighborOfType(row, col, 'isOddEven')) {
                         board[row][col].isOddEven = true;
                         board[row][col].isHide = true; // OddEven implies Hide
                         board[row][col].oddEvenValue = board[row][col].adjacentMines % 2 === 0 ? 'Ev' : 'Od';
                         appliedCount++;
                    }
                }
            }

            // Apply simple Hide last
             if (enableHide) {
                 // Note: minHideRate is currently 0, adjust if needed
                 const hideRate = Math.random() * (maxHideRate - minHideRate) + minHideRate;
                 const maxHide = Math.floor(totalSquares * hideRate);
                 appliedCount = 0;
                 for (let k = 0; k < potentialSquares.length && appliedCount < maxHide; k++) {
                      const { row, col } = potentialSquares[k];
                      // Only apply if not already hidden by other types
                      if (!board[row][col].isHide) {
                          board[row][col].isHide = true;
                          appliedCount++;
                      }
                 }
             }
        }

        // Helper function to check neighbors for a specific type
        function hasNeighborOfType(row, col, typeKey) {
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    if (x === 0 && y === 0) continue;
                    const ni = row + x;
                    const nj = col + y;
                    if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize && board[ni][nj][typeKey]) {
                        return true;
                    }
                }
            }
            return false;
        }


        function handleSquareClick(row, col) {
            if (gameOver || board[row][col].isRevealed || board[row][col].isFlagged) {
                return;
            }

            // Start timer on first click
            if (!gameStarted) {
                gameStarted = true;
                timerInterval = setInterval(updateTimer, 1000);
            }

            const square = board[row][col];

            if (square.isMine) {
                revealMine(row, col); // Show the clicked mine
                endGame(false); // Game over, player lost
            } else {
                revealSquare(row, col);
                checkWinCondition();
            }
            // updateDisplay is called within revealSquare and endGame
        }

         function revealMine(row, col) {
            const square = board[row][col];
            square.isRevealed = true;
            square.element.classList.remove('hidden', 'flagged'); // Remove hidden and flag if present
            square.element.classList.add('revealed', 'mine');
            square.element.style.backgroundColor = '#ff0000'; // Highlight the clicked mine
            square.element.textContent = '💥'; // Different symbol for clicked mine
         }

        function revealSquare(row, col) {
            // Boundary and state checks
            if (row < 0 || row >= gridSize || col < 0 || col >= gridSize || gameOver) return;
            const square = board[row][col];
            if (square.isRevealed || square.isFlagged || square.isMine) return;

            square.isRevealed = true;
            revealedNonMineCount++; // Increment revealed count here
            square.element.classList.remove('hidden');
            square.element.classList.add('revealed');
            renderSquareContent(square); // Update visual content

            // If the revealed square has 0 adjacent mines, reveal neighbors recursively
            if (square.adjacentMines === 0) {
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                         // Skip self and diagonal checks if you want classic minesweeper flood fill
                         // if (x === 0 && y === 0) continue;
                        revealSquare(row + x, col + y);
                    }
                }
            }
        }

        function renderSquareContent(square) {
             if (!square.isRevealed) {
                 if (square.isFlagged) {
                     square.element.textContent = '🚩';
                 } else {
                     square.element.textContent = '';
                     square.element.classList.add('hidden');
                     square.element.classList.remove('revealed'); // Ensure revealed is removed if flagged then unflagged
                 }
             } else {
                 square.element.classList.remove('hidden');
                 square.element.classList.add('revealed');
                 if (square.isMine) {
                    // This case is handled by revealAllMines in endGame or revealMine
                    // square.element.textContent = '💣';
                 } else if (square.adjacentMines > 0) {
                    if (square.isHide) {
                         square.element.classList.add('special-square'); // Common class for special ones
                         if (square.isOddEven) {
                            square.element.textContent = square.oddEvenValue;
                            square.element.classList.add('odd-even-square');
                         } else if (square.isAreaValue) {
                            square.element.textContent = square.areaValue;
                            square.element.classList.add('area-value-square');
                         } else {
                            // Simple hide square
                            square.element.textContent = '・';
                         }
                    } else {
                        // Regular number square
                        square.element.textContent = square.adjacentMines;
                        // Optional: Add number-specific classes for color styling
                        // square.element.classList.add(`num-${square.adjacentMines}`);
                    }
                 } else {
                     // Empty revealed square
                     square.element.textContent = '';
                 }
             }
        }


        function handleRightClick(row, col) {
            if (gameOver || board[row][col].isRevealed) {
                return;
            }

            // Start timer on first flag if not started
            if (!gameStarted) {
                 gameStarted = true;
                 timerInterval = setInterval(updateTimer, 1000);
            }

            const square = board[row][col];
            square.isFlagged = !square.isFlagged; // Toggle flag

            if (square.isFlagged) {
                minesLeft--;
            } else {
                minesLeft++;
            }

            renderSquareContent(square); // Update only this square's display
            updateMinesLeftDisplay(); // Update mine counter
        }

        function updateMinesLeftDisplay() {
             messageBox.textContent = `Mines Left: ${minesLeft}`;
        }

        function checkWinCondition() {
            const totalNonMineSquares = gridSize * gridSize - numMines;
            if (revealedNonMineCount === totalNonMineSquares) {
                endGame(true); // Game over, player won
            }
        }

        function endGame(isWin) {
            gameOver = true;
            clearInterval(timerInterval);

            if (isWin) {
                messageBox.textContent = 'Game Clear!';
                body.style.backgroundColor = '#aaffaa'; // Greenish background for win
                 // Optionally flag remaining mines automatically
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (board[i][j].isMine && !board[i][j].isFlagged) {
                             board[i][j].isFlagged = true;
                             renderSquareContent(board[i][j]);
                        }
                    }
                }
                 updateMinesLeftDisplay(); // Show 0 mines left

            } else {
                messageBox.textContent = 'Game Over!';
                body.classList.add('game-over'); // Use class for red background
                revealAllMines(false); // Show all mines, mark incorrect flags
            }
        }

        function revealAllMines(revealContent) {
             for (let i = 0; i < gridSize; i++) {
                 for (let j = 0; j < gridSize; j++) {
                     const square = board[i][j];
                     if (square.isMine) {
                         if (!square.isRevealed) { // Avoid re-rendering the clicked mine differently
                            square.isRevealed = true;
                            square.element.classList.remove('hidden', 'flagged');
                            square.element.classList.add('revealed', 'mine');
                            if (revealContent) {
                                square.element.textContent = '💣';
                            }
                         }
                     } else if (square.isFlagged) {
                         // Incorrectly flagged square
                         square.element.textContent = '❌';
                         square.element.style.backgroundColor = '#fdd'; // Light red background
                     } else if (revealContent && !square.isRevealed) {
                         // Reveal non-mine squares if revealAll is called
                         square.isRevealed = true;
                         renderSquareContent(square);
                     }
                 }
             }
        }

        function updateTimer() {
            seconds++;
            updateTimerDisplay();
        }

        function updateTimerDisplay() {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            // Hide hours if 0
            const formattedTime = hours > 0
                ? `${hours}:${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`
                : `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            timerDisplay.textContent = formattedTime;
        }

        // --- Debug Functions ---
        function revealNonMines() {
            if (gameOver) return; // Don't allow debug after game ends normally
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (!board[i][j].isMine && !board[i][j].isRevealed) {
                         revealSquare(i,j); // Use existing reveal logic
                    }
                }
            }
             checkWinCondition(); // Should immediately trigger win
             if (!gameOver) { // Should not happen if logic is correct, but as fallback
                endGame(true);
             }
        }

        function revealAll() {
             if (gameOver) return; // Don't allow debug after game ends normally
             revealAllMines(true); // Reveal mines and content
             endGame(false); // Consider reveal all as a loss for scoring/timing
             messageBox.textContent = 'All squares revealed!'; // Override end game message
        }

        // --- Initial Setup ---
        createBoard(); // Create the initial board on page load

    </script>
</body>
</html>
