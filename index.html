    <script>
        const gridSize = 15;
        const numMines = 30;
        // --- Rates ---
        const maxHideRate = 0.15;
        const minHideRate = 0;
        const maxOddEvenRate = 0.05;
        const maxAreaValueRate = 0.10;
        const maxDirectionalRate = 0.10; // ★ 新しいレート

        // --- Board state ---
        let board = [];
        let minesLeft = numMines;
        let gameOver = false;
        let timerInterval;
        let seconds = 0;
        let revealedNonMineCount = 0;
        let gameStarted = false;

        // --- Get DOM Elements ---
        // ... (existing element getters) ...
        const directionalSwitch = document.getElementById('directional-switch'); // ★ 新しいスイッチ

        // --- Settings ---
        let enableNumbers = numberSwitch.checked;
        let enableHide = hideSwitch.checked;
        let enableOddEven = oddEvenSwitch.checked;
        let enableAreaValue = areaValueSwitch.checked;
        let enableDirectional = directionalSwitch.checked; // ★ 新しい設定変数

        // --- Event Listeners ---
        // ... (existing listeners) ...
        directionalSwitch.addEventListener('change', handleSettingChange); // ★ 新しいリスナー

        // --- Popup Functions ---
        function openPopup() { /* ... no change ... */ }
        function closePopup() { /* ... no change ... */ }

        function handleSettingChange() {
            // Update all settings from their switches
            enableNumbers = numberSwitch.checked;
            enableHide = hideSwitch.checked;
            enableOddEven = oddEvenSwitch.checked;
            enableAreaValue = areaValueSwitch.checked;
            enableDirectional = directionalSwitch.checked; // ★ 更新
            resetGame();
        }

        // --- Game Logic Functions ---
        function resetGame() { /* ... no change ... */ }

        function createBoard() {
            board = [];
            minesLeft = numMines;
            gameOver = false;
            revealedNonMineCount = 0;
            boardElement.innerHTML = '';

            for (let i = 0; i < gridSize; i++) {
                board[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    board[i][j] = {
                        isMine: false, isRevealed: false, isFlagged: false,
                        adjacentMines: 0, // Regular adjacent count
                        // Special Square Flags & Data
                        isHide: false,
                        isOddEven: false, oddEvenValue: null,
                        isAreaValue: false, areaValue: null,
                        isDirectional: false, direction: null, directionalCount: null, directionalSymbol: null, // ★ 追加
                        element: document.createElement('div')
                    };
                    // ... (element setup and listeners) ...
                     const square = board[i][j];
                     const squareElement = square.element;
                     squareElement.classList.add('square', 'hidden');
                     squareElement.dataset.row = i; squareElement.dataset.col = j;
                     squareElement.addEventListener('click', () => handleSquareClick(i, j));
                     squareElement.addEventListener('contextmenu', (event) => { event.preventDefault(); handleRightClick(i, j); });
                     // Touch listener
                     let pressTimer;
                     squareElement.addEventListener('touchstart', (event) => {
                         pressTimer = setTimeout(() => { event.preventDefault(); handleRightClick(i, j); }, 500);
                     }, { passive: false });
                     squareElement.addEventListener('touchend', () => { clearTimeout(pressTimer); });
                     squareElement.addEventListener('touchmove', () => { clearTimeout(pressTimer); });
                     boardElement.appendChild(squareElement);
                }
            }
            plantMines();
            calculateAdjacentMines(); // Calculate regular adjacent mines first
            // ★ Calculate directional counts *before* applying special squares
            //    so the data is available when deciding if a square becomes directional.
            //    (We'll calculate on demand within applySpecialSquares instead for simplicity now)
            applySpecialSquares();
            updateMinesLeftDisplay();
        }

        function plantMines() { /* ... no change ... */ }
        function calculateAdjacentMines() { /* ... no change ... */ }

        // ★ 新しいヘルパー関数: 指定方向の地雷を数える
        function countMinesInDirection(startRow, startCol, dx, dy) {
            let count = 0;
            let r = startRow + dx;
            let c = startCol + dy;
            while (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
                if (board[r][c]?.isMine) { // Check if mine exists at this position
                    count++;
                }
                r += dx;
                c += dy;
            }
            return count;
        }

        // ★ applySpecialSquares 関数を更新
        function applySpecialSquares() {
            const potentialNumberSquares = [];
            // Reset flags and collect potential squares
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const square = board[i][j];
                    square.isHide = false;
                    square.isOddEven = false;
                    square.isAreaValue = false;
                    square.isDirectional = false; // ★ Reset directional flag
                    square.oddEvenValue = null;
                    square.areaValue = null;
                    square.direction = null;
                    square.directionalCount = null;
                    square.directionalSymbol = null;
                    if (!square.isMine && square.adjacentMines > 0) {
                        potentialNumberSquares.push({ r: i, c: j });
                    }
                }
            }
            potentialNumberSquares.sort(() => Math.random() - 0.5);

            const assignedSpecial = new Set();
            const totalSquares = gridSize * gridSize;

            // Define possible directions and their symbols
            const directions = [
                { dx: -1, dy: 0, symbol: '↑' }, { dx: 1, dy: 0, symbol: '↓' },
                { dx: 0, dy: -1, symbol: '←' }, { dx: 0, dy: 1, symbol: '→' },
                { dx: -1, dy: -1, symbol: '↖' }, { dx: -1, dy: 1, symbol: '↗' },
                { dx: 1, dy: -1, symbol: '↙' }, { dx: 1, dy: 1, symbol: '↘' }
            ];

            if (!enableNumbers) {
                // --- Numbers OFF: Apply special types deterministically ---
                // Order: Directional -> AreaValue -> OddEven -> Hide
                // Apply Directional first (if enabled)
                if (enableDirectional) {
                    for (const { r, c } of potentialNumberSquares) {
                        const k = `${r}-${c}`;
                         // No neighbor check needed for directional based on current rules
                        if (!assignedSpecial.has(k)) {
                            const sq = board[r][c];
                            const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                            const count = countMinesInDirection(r, c, randomDirection.dx, randomDirection.dy);

                            sq.isDirectional = true; sq.isHide = true;
                            sq.direction = { dx: randomDirection.dx, dy: randomDirection.dy };
                            sq.directionalCount = count;
                            sq.directionalSymbol = randomDirection.symbol;
                            assignedSpecial.add(k);
                        }
                    }
                }
                // Apply AreaValue (if enabled and not already directional)
                if (enableAreaValue) {
                    for (const { r, c } of potentialNumberSquares) {
                        const k = `${r}-${c}`;
                        if (!assignedSpecial.has(k) && !hasNeighborOfType(r, c, 'isAreaValue')) {
                            // ... set AreaValue ...
                            const sq = board[r][c];
                            sq.isAreaValue = true; sq.isHide = true;
                            if (sq.adjacentMines <= 3) sq.areaValue = '-3';
                            else if (sq.adjacentMines <= 6) sq.areaValue = '4-6';
                            else sq.areaValue = '7+';
                            assignedSpecial.add(k);
                        }
                    }
                }
                 // Apply OddEven (if enabled and not already special)
                if (enableOddEven) {
                     for (const { r, c } of potentialNumberSquares) {
                        const k = `${r}-${c}`;
                        const sq = board[r][c];
                        if (!assignedSpecial.has(k) && sq.adjacentMines > 1 && !hasNeighborOfType(r, c, 'isOddEven')) {
                            sq.isOddEven = true; sq.isHide = true;
                            sq.oddEvenValue = sq.adjacentMines % 2 === 0 ? 'Ev' : 'Od';
                            assignedSpecial.add(k);
                        }
                    }
                }
                // Remaining become Hide
                for (const { r, c } of potentialNumberSquares) {
                    const k = `${r}-${c}`;
                    if (!assignedSpecial.has(k)) {
                        board[r][c].isHide = true;
                    }
                }
            } else {
                // --- Numbers ON: Apply special types probabilistically ---
                // Order: Directional -> AreaValue -> OddEven -> Hide
                // Apply Directional (if enabled)
                if (enableDirectional) {
                    const maxDir = Math.floor(totalSquares * maxDirectionalRate); let count = 0;
                    for (const { r, c } of potentialNumberSquares) {
                        if (count >= maxDir) break; const k = `${r}-${c}`;
                        if (!assignedSpecial.has(k)) { // Apply if not already assigned
                            const sq = board[r][c];
                            const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                            const dirCount = countMinesInDirection(r, c, randomDirection.dx, randomDirection.dy);

                            sq.isDirectional = true; sq.isHide = true;
                            sq.direction = { dx: randomDirection.dx, dy: randomDirection.dy };
                            sq.directionalCount = dirCount;
                            sq.directionalSymbol = randomDirection.symbol;
                            assignedSpecial.add(k); count++;
                        }
                    }
                }
                // Apply AreaValue (if enabled and not assigned)
                if (enableAreaValue) {
                    const max = Math.floor(totalSquares * maxAreaValueRate); let count = 0;
                     for (const { r, c } of potentialNumberSquares) {
                        if (count >= max) break; const k = `${r}-${c}`;
                         if (!assignedSpecial.has(k) && !hasNeighborOfType(r, c, 'isAreaValue')) {
                             // ... set AreaValue ...
                             const sq = board[r][c];
                             sq.isAreaValue = true; sq.isHide = true;
                             if (sq.adjacentMines <= 3) sq.areaValue = '-3';
                             else if (sq.adjacentMines <= 6) sq.areaValue = '4-6';
                             else sq.areaValue = '7+';
                             assignedSpecial.add(k); count++;
                         }
                     }
                }
                 // Apply OddEven (if enabled and not assigned)
                if (enableOddEven) {
                    const max = Math.floor(totalSquares * maxOddEvenRate); let count = 0;
                     for (const { r, c } of potentialNumberSquares) {
                        if (count >= max) break; const k = `${r}-${c}`;
                        const sq = board[r][c];
                        if (!assignedSpecial.has(k) && sq.adjacentMines > 1 && !hasNeighborOfType(r, c, 'isOddEven')) {
                           // ... set OddEven ...
                            sq.isOddEven = true; sq.isHide = true;
                            sq.oddEvenValue = sq.adjacentMines % 2 === 0 ? 'Ev' : 'Od';
                            assignedSpecial.add(k); count++;
                        }
                    }
                }
                 // Apply simple Hide (if enabled and not assigned)
                if (enableHide) {
                    const rate = Math.random() * (maxHideRate - minHideRate) + minHideRate;
                    const max = Math.floor(totalSquares * rate); let count = 0;
                     for (const { r, c } of potentialNumberSquares) {
                        if (count >= max) break; const k = `${r}-${c}`;
                         if (!assignedSpecial.has(k)) {
                             board[r][c].isHide = true;
                             // assignedSpecial.add(k); // Optionally track
                             count++;
                         }
                     }
                 }
            }
        }

        function hasNeighborOfType(r, c, key) { /* ... no change ... */ }
        function handleSquareClick(r, c) { /* ... no change ... */ }
        function revealMine(r, c) { /* ... no change ... */ }
        function revealSquare(r, c) { /* ... no change ... */ }

        // ★ renderSquareContent 関数を更新
        function renderSquareContent(sq) {
            const el = sq.element;
            // Reset classes and content
            el.className = 'square'; // Start with base class
            el.textContent = '';

            if (!sq.isRevealed) {
                el.classList.add('hidden');
                if (sq.isFlagged) {
                    el.textContent = '🚩';
                }
            } else {
                el.classList.add('revealed');
                if (sq.isMine) {
                     el.classList.add('mine');
                     if (el.classList.contains('mine-clicked')) { // Check if it's the clicked one
                         el.textContent = '💥';
                     } else {
                         el.textContent = '💣';
                     }
                } else if (sq.adjacentMines > 0) { // Only check special types if adjacentMines > 0
                    // Check special types in order of preference for display
                    if (sq.isDirectional) { // ★ Check Directional first
                        el.classList.add('directional-square'); // ★ Add directional class
                        el.textContent = sq.directionalSymbol + sq.directionalCount;
                    } else if (sq.isAreaValue) {
                        el.classList.add('special-square', 'area-value-square');
                        el.textContent = sq.areaValue;
                    } else if (sq.isOddEven) {
                        el.classList.add('special-square', 'odd-even-square');
                        el.textContent = sq.oddEvenValue;
                    } else if (sq.isHide) { // Check simple hide last before number
                        el.classList.add('special-square');
                        el.textContent = '・';
                    } else {
                        // Only display number if no special type was applied
                        el.textContent = sq.adjacentMines;
                        // Optional: Add number class, e.g., el.classList.add(`num-${sq.adjacentMines}`);
                    }
                } else {
                    // Revealed blank square (adjacentMines === 0)
                    el.textContent = '';
                }

                 // Handle incorrectly flagged square display if revealed
                 if (el.classList.contains('flag-wrong')) {
                    el.textContent = '❌';
                     el.classList.add('flag-wrong'); // Ensure class remains for styling
                 }
            }
        }


        function handleRightClick(r, c) { /* ... no change ... */ }
        function updateMinesLeftDisplay() { /* ... no change ... */ }
        function checkWinCondition() { /* ... no change ... */ }
        function endGame(isWin) { /* ... no change ... */ }
        function revealAllMines(showContent) { /* ... no change ... */ }
        function updateTimer() { /* ... no change ... */ }
        function updateTimerDisplay() { /* ... no change ... */ }
        function revealNonMines() { /* ... no change ... */ }
        function revealAll() { /* ... no change ... */ }

        // --- Initial Setup ---
        createBoard();

    </script>
</body>
</html>
