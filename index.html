<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper 2</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Theme */
            --bg-color: #f0f0f0;
            --text-color: #333;
            --container-bg: #f0f0f0;
            --board-bg: #b4c687;
            --board-border: #333;
            --square-border: #333;
            --square-hidden-bg: #ddd;
            --square-revealed-bg: #b4c687;
            --square-text-color: #000;
            --mine-bg: #ff4444;
            --mine-clicked-bg: #cc0000;
            --mine-clicked-text: #fff;
            --flag-wrong-bg: #fdd;
            --flag-wrong-text: #000;
            --button-bg: #e0e0e0;
            --button-border: #999;
            --button-text: #333;
            --button-hover-bg: #d0d0d0;
            --popup-bg: #fdfdfd;
            --popup-border: #333;
            --popup-text: #333;
            --popup-header-text: #111;
            --popup-setting-bg: #f0f0f0;
            --popup-setting-border: #ddd;
            --popup-footer-bg: #f9f9f9;
            --popup-footer-border: #ccc;
            --blind-rule-base-bg: #fff0f0;    /* Base blind bg */
            --blind-rule-base-border: #8B0000; /* Base blind border */
            --blind-rule-text: #333;          /* Blind text color (light) */
            --slider-bg: #ccc;
            --slider-checked-bg: #2196F3;
            --switch-thumb-bg: white;
            --low-time-bg: #FDBE00;
            --game-over-bg: #ff4444;
            --rule-directional-color: #1a759f;
            --rule-oddeven-color: #0000CD;
            --rule-areavalue-color: #902094;
            --rule-natural-color: #2E8B57;
            --rule-timebomb-color: #DC143C;
            --rule-gameovertime-color: #A0522D;
            --rule-blind-color: #8B0000;
        }

        body[data-theme="dark"] {
            /* Dark Theme */
            --bg-color: #222;
            --text-color: #eee;
            --container-bg: #2a2a2a;
            --board-bg: #5a6642;
            --board-border: #aaa;
            --square-border: #666;
            --square-hidden-bg: #555;
            --square-revealed-bg: #5a6642;
            --square-text-color: #ffffff;
            --mine-bg: #b00000;
            --mine-clicked-bg: #ff4444;
            --mine-clicked-text: #000;
            --flag-wrong-bg: #803030;
            --flag-wrong-text: #eee;
            --button-bg: #444;
            --button-border: #777;
            --button-text: #eee;
            --button-hover-bg: #555;
            --popup-bg: #333;
            --popup-border: #aaa;
            --popup-text: #ddd;
            --popup-header-text: #fff;
            --popup-setting-bg: #444;
            --popup-setting-border: #666;
            --popup-footer-bg: #2a2a2a;
            --popup-footer-border: #555;
            --blind-rule-base-bg: #4d0000;    /* Base blind bg (dark) */
            --blind-rule-base-border: #ff8080; /* Base blind border (dark) */
            --blind-rule-text: #eee;          /* Blind text color (dark) */
            --slider-bg: #666;
            --slider-checked-bg: #0077cc;
            --switch-thumb-bg: #ccc;
            --low-time-bg: #b38600;
            --game-over-bg: #b00000;
            --rule-directional-color: #61c0e8;
            --rule-oddeven-color: #87CEFA;
            --rule-areavalue-color: #d689da;
            --rule-natural-color: #90EE90;
            --rule-timebomb-color: #ff7f50;
            --rule-gameovertime-color: #deb887;
            --rule-blind-color: #ff8080;
        }

        body {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; padding: 10px 0;
            background-color: var(--bg-color); color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: hidden;
        }
        body.game-over { background-color: var(--game-over-bg); }
        body.low-time { background-color: var(--low-time-bg); }

        #game-container {
            display: flex; flex-direction: column; align-items: center;
            margin-bottom: 12px; position: relative; width: 95%;
            max-width: 420px;
            background-color: var(--container-bg);
            padding: 10px; border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }

        #blind-rule-display {
            font-family: 'DotGothic16', sans-serif; font-size: 13px; color: var(--blind-rule-text);
            margin-bottom: 8px; line-height: 1.5; min-height: 35px; width: 100%;
            max-width: 412px;
            padding: 5px 8px; box-sizing: border-box;
            /* Base colors set by CSS variables */
            border: 2px solid var(--blind-rule-base-border);
            background-color: var(--blind-rule-base-bg);
            display: none;
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        }
        #blind-rule-display.visible { display: block; }
        #blind-rule-display strong { font-size: 14px; display: block; margin-bottom: 3px; font-weight: bold; text-align: left; font-family: 'Press Start 2P', cursive; }
        #blind-rule-display span { display: block; text-align: center; }

        #game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 412px; margin-bottom: 5px; padding: 0 5px; box-sizing: border-box; min-height: 30px; position: relative; }

        #board {
            display: grid;
            grid-template-columns: repeat(20, 20px);
            border: 2px solid var(--board-border); background-color: var(--board-bg);
            padding: 4px; margin-top: 5px; margin-bottom: 10px;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .square {
            width: 20px; height: 20px;
            border: 1px solid var(--square-border); display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 11px; user-select: none;
            background-color: var(--square-hidden-bg);
            line-height: 1; overflow: hidden; text-align: center;
            color: var(--square-text-color);
            transition: background-color 0.1s, border-color 0.1s, color 0.1s;
        }
        .hidden { background-color: var(--square-hidden-bg); }
        .revealed { background-color: var(--square-revealed-bg); }
        .mine { background-color: var(--mine-bg); font-size: 12px; }
        .mine-clicked { background-color: var(--mine-clicked-bg); color: var(--mine-clicked-text); font-size: 14px; }
        .flag-wrong { background-color: var(--flag-wrong-bg) !important; color: var(--flag-wrong-text); font-weight: bold; font-size: 14px; }

        /* Buttons */
        #reset-button, #rules-button, #debug-buttons button, #save-settings-button, #reset-all-settings-button, .reset-rule-button { padding: 6px 12px; font-size: 12px; cursor: pointer; font-family: 'Press Start 2P', cursive; background-color: var(--button-bg); border: 1px solid var(--button-border); color: var(--button-text); border-radius: 3px; transition: background-color 0.2s, border-color 0.2s; }
        #reset-button { margin-top: 8px; }
        #rules-button { font-size: 10px; padding: 5px 8px; margin-top: 0; order: 3; }
        #reset-button:hover, #rules-button:hover, #debug-buttons button:hover, #save-settings-button:hover, #reset-all-settings-button:hover, .reset-rule-button:hover { background-color: var(--button-hover-bg); }
        #save-settings-button { background-color: #4CAF50; color: white; margin-top: 0; }
        body[data-theme="dark"] #save-settings-button { background-color: #388E3C; }
        #save-settings-button:hover { background-color: #45a049; }
        body[data-theme="dark"] #save-settings-button:hover { background-color: #2E7D32; }
        #reset-all-settings-button { background-color: #f44336; color: white; margin-top: 0; margin-right: 10px; }
        body[data-theme="dark"] #reset-all-settings-button { background-color: #c62828; }
        #reset-all-settings-button:hover { background-color: #e53935; }
        body[data-theme="dark"] #reset-all-settings-button:hover { background-color: #b71c1c; }
        .reset-rule-button { font-size: 9px; padding: 2px 6px; margin-left: 10px; font-family: sans-serif; }

        #info-controls { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 412px; }
        #message-box { font-size: 12px; color: var(--text-color); margin-bottom: 2px; height: 14px; text-align: center; transition: color 0.3s; }
        #active-rules-display { font-size: 9px; color: var(--text-color); opacity: 0.8; margin-top: 0px; margin-bottom: 8px; line-height: 1.3; text-align: center; min-height: 40px; transition: color 0.3s; }
        #active-rules-display div { margin-bottom: 2px; }
        #active-rules-display .rule-display-directional { color: var(--rule-directional-color); }
        #active-rules-display .rule-display-oddEven { color: var(--rule-oddeven-color); }
        #active-rules-display .rule-display-areaValue { color: var(--rule-areavalue-color); }
        #active-rules-display .rule-display-naturalNumber { color: var(--rule-natural-color); }
        #active-rules-display .rule-display-timeBomb { color: var(--rule-timebomb-color); }
        #active-rules-display .rule-display-gameOverOnTimeOnly { color: var(--rule-gameovertime-color); }
        #active-rules-display .rule-display-blind { color: var(--rule-blind-color); font-weight: bold; }

        .timer { font-size: 14px; color: var(--text-color); text-align: center; order: 2; flex-grow: 1; margin: 0; transition: color 0.3s ease; }
        .timer.blinking-black span { animation: blink-black-anim 1s infinite; }
        .timer.blinking-red span { animation: blink-red-anim 1s infinite; }
        .timer.blinking-basketball span { animation: blink-basketball-anim 0.8s infinite; }
        @keyframes blink-black-anim { 0%, 49% { color: var(--square-text-color); } 50%, 100% { color: var(--text-color); } }
        @keyframes blink-red-anim { 0%, 49% { color: red; } 50%, 100% { color: var(--text-color); } }
        @keyframes blink-basketball-anim { 0%, 49% { color: #ff0000; } 50%, 100% { color: var(--square-text-color); } }

        .switch { position: relative; display: inline-block; width: 40px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--slider-bg); transition: .4s; border-radius: 18px; }
        .slider:before { position: absolute; content: ""; height: 10px; width: 10px; left: 4px; bottom: 4px; background-color: var(--switch-thumb-bg); transition: .4s; border-radius: 50%; }
        input:checked+.slider { background-color: var(--slider-checked-bg); }
        input:focus+.slider { box-shadow: 0 0 1px var(--slider-checked-bg); }
        input:checked+.slider:before { transform: translateX(22px); }
        .slider.round { border-radius: 18px; }
        .slider.round:before { border-radius: 50%; }

        .special-square { font-size: 9px; }
        .odd-even-square { color: var(--rule-oddeven-color); font-weight: bold; }
        .area-value-square { color: var(--rule-areavalue-color); font-weight: bold; font-size: 9px; }
        .directional-square { color: var(--rule-directional-color); font-weight: bold; font-size: 9px; }
        .natural-number-square { color: var(--rule-natural-color); font-weight: bold; }
        /* Standard number colors inherit --square-text-color set by theme */

        #debug-buttons { display: none; margin-top: 8px; }
        #debug-buttons.visible { display: flex; gap: 4px; }
        #debug-buttons button { margin-left: 0; padding: 6px 10px; font-size: 10px; }

        #mode-toggle-buttons { display: none; user-select: none; order: 1; }
        #mode-toggle-buttons.visible { display: flex; gap: 5px; }
        .mode-button { font-size: 20px; padding: 3px 6px; cursor: pointer; border: 2px solid var(--button-border); background-color: var(--button-bg); color: var(--button-text); border-radius: 5px; line-height: 1; transition: background-color 0.2s, border-color 0.2s; }
        .mode-button.active { background-color: var(--button-hover-bg); border-color: var(--text-color); box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); }
        body[data-theme="dark"] .mode-button.active { border-color: var(--text-color); box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.2); }
        #flag-mode-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: var(--button-bg); border-color: var(--button-border); box-shadow: none; }

        /* --- Popup Styles --- */
        #popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 99; display: none; }
        #rules-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px; background-color: var(--popup-bg); border: 2px solid var(--popup-border); color: var(--popup-text); border-radius: 8px; z-index: 100; display: none; font-size: 11px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25); font-family: sans-serif; flex-direction: column; transition: background-color 0.3s, border-color 0.3s, color 0.3s; }
        #popup-overlay.visible, #rules-popup.visible { display: flex !important; }
        .popup-header { padding: 15px 20px 0 20px; }
        .popup-header h2 { margin-top: 0; margin-bottom: 15px; font-size: 18px; text-align: center; font-family: 'Press Start 2P', cursive; color: var(--popup-header-text); }
        .rules-content { max-height: 65vh; overflow-y: auto; padding: 0 20px 10px 20px; }
        #rules-popup h3 { font-size: 14px; margin-bottom: 10px; margin-top: 18px; border-bottom: 1px solid var(--popup-footer-border); padding-bottom: 4px; font-weight: bold; }
        #rules-popup h4 { font-size: 13px; margin-bottom: 6px; margin-top: 12px; font-weight: bold; color: var(--text-color); opacity: 0.9; }
        #rules-popup p { margin-bottom: 12px; line-height: 1.5; font-size: 12px; }
        #close-popup-button { position: absolute; top: 8px; right: 8px; background: none; border: 1px solid transparent; font-size: 26px; font-weight: bold; color: #777; cursor: pointer; font-family: sans-serif; line-height: 1; padding: 0 6px; transition: color 0.2s, border-color 0.2s; }
        body[data-theme="dark"] #close-popup-button { color: #aaa; }
        #close-popup-button:hover, #close-popup-button:focus { color: var(--text-color); border-color: #ccc; outline: none; }
        #rules-popup .setting-section { background-color: var(--popup-setting-bg); padding: 10px 15px; border-radius: 4px; margin-bottom: 12px; border: 1px solid var(--popup-setting-border); transition: background-color 0.3s, border-color 0.3s; }
        #rules-popup .setting-label { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0; font-size: 12px; margin-top: 8px; font-weight: bold; font-family: 'Press Start 2P', cursive; }
        #rules-popup .switch { margin-left: 8px; }
        .popup-footer { padding: 10px 20px; text-align: right; border-top: 1px solid var(--popup-footer-border); background-color: var(--popup-footer-bg); margin-top: auto; display: flex; justify-content: flex-end; align-items: center; transition: background-color 0.3s, border-color 0.3s; }

        #mine-slider { width: 100%; cursor: pointer; margin-top: 5px; }
        #mine-count-display { font-weight: bold; margin-left: 5px; font-family: sans-serif; font-size: 13px; }
        .slider-label { display: flex; justify-content: space-between; align-items: center; font-size: 12px; font-family: 'Press Start 2P', cursive; margin-bottom: 5px; }

        #hide-rate-control { margin-top: 10px; }
        #hide-rate-slider-label { display: flex; justify-content: space-between; align-items: center; font-size: 11px; margin-bottom: 3px; font-weight: normal; }
        #hide-rate-display { font-weight: bold; margin-left: 5px; font-family: sans-serif; font-size: 12px; }
        #hide-rate-slider { width: 100%; cursor: pointer; }
        .setting-section[data-rule-id="hide"] > #hide-rate-control:not(.enabled) { opacity: 0.5; pointer-events: none; }

        .pc-op-mode-label { display: block; margin-bottom: 5px; font-size: 12px; cursor: pointer; }
        .pc-op-mode-label input[type="radio"] { margin-right: 5px; }
        #pc-op-mode-section { display: block; }
        body.touch-device #pc-op-mode-section { display: none; }
        body:not(.touch-device)[data-pc-op-mode="mouse"] #mode-toggle-buttons { display: none; }

        #timer-start-display { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(2); font-size: 48px; font-family: 'Press Start 2P', cursive; color: var(--text-color); border-radius: 5px; z-index: 101; opacity: 0; pointer-events: none; transition: transform 0.4s ease-out, opacity 0.4s ease-out, top 0.4s ease-out, left 0.4s ease-out, font-size 0.4s ease-out, color 0.4s ease-out; animation: start-blink 1s infinite; }
        #timer-start-display.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #timer-start-display.move-to-corner { top: 25px; left: 50%; transform: translateX(-50%) scale(0.6); font-size: 14px; opacity: 0; color: var(--text-color); animation: none; }
        .timer.hide-during-intro { visibility: hidden; }
        @keyframes start-blink { 0%, 49% { opacity: 1; } 50%, 100% { opacity: 0.5; } }

        body.timer-intro-active * { pointer-events: none !important; }
        body.timer-intro-active #rules-popup, body.timer-intro-active #popup-overlay { pointer-events: auto !important; }
        body.timer-intro-active #rules-popup * { pointer-events: auto !important; }

        #time-bomb-details { margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--popup-footer-border); }
        #time-bomb-details > div { margin-bottom: 10px; }
        .time-input-group { display: flex; align-items: center; margin-bottom: 6px; }
        .time-input-group label { display: inline-block; width: 65px; text-align: right; margin-right: 5px; font-size: 11px; font-family: sans-serif; font-weight: bold; color: var(--popup-text); }
        .time-input-group input[type="number"] { width: 40px; padding: 4px; font-size: 12px; font-family: sans-serif; border: 1px solid var(--popup-setting-border); background-color: var(--bg-color); color: var(--text-color); border-radius: 3px; text-align: right; -moz-appearance: textfield; appearance: textfield; transition: background-color 0.3s, color 0.3s, border-color 0.3s; }
        .time-input-group input[type="number"]::-webkit-outer-spin-button, .time-input-group input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .time-input-group span.colon { font-size: 14px; font-weight: bold; margin: 0 3px; font-family: sans-serif; color: var(--popup-text); }

        #time-bomb-random-switch-label, #game-over-on-time-only-label { display: flex; align-items: center; justify-content: space-between; font-size: 11px; font-weight: normal; font-family: 'Press Start 2P', cursive; margin-bottom: 5px; }
        .time-setting-note { display: block; font-size: 10px; color: #666; margin-top: 4px; font-family: sans-serif; text-align: center; }
        body[data-theme="dark"] .time-setting-note { color: #aaa; }
        .hidden-setting { display: none !important; }
        .disabled-setting { opacity: 0.5; pointer-events: none; }
        .disabled-setting input, .disabled-setting button, .disabled-setting .switch { cursor: not-allowed !important; }

        #rules-popup .setting-section[data-rule-id="blind"] { margin-top: 20px; padding-top: 15px; border-top: 2px solid var(--popup-setting-border); position: relative; }
        .disabled-reason { position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background-color: rgba(255, 220, 220, 0.9); color: #8B0000; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-family: sans-serif; font-weight: bold; display: none; z-index: 1; white-space: nowrap; }
        body[data-theme="dark"] .disabled-reason { background-color: rgba(60, 0, 0, 0.9); color: #ffcccc; }
        .setting-section[data-rule-id="blind"].disabled-setting .disabled-reason { display: block; }
    </style>
</head>

<body data-theme="light">
    <div id="game-container">
        <div id="blind-rule-display">
            <strong>Blind Rule: Title</strong>
            <span>Description</span>
        </div>
        <div id="game-header">
            <div id="mode-toggle-buttons">
                <button id="dig-mode-button" class="mode-button active" title="掘るモード">⛏️</button>
                <button id="flag-mode-button" class="mode-button" title="旗モード">🚩</button>
            </div>
            <div class="timer" id="timer-container">
                Time: <span id="timer-value">00.00</span>
            </div>
            <button id="rules-button">Rules & Settings</button>
        </div>

        <div id="board"></div>

        <div id="info-controls">
            <div id="message-box">Click a square to start!</div>
            <div id="active-rules-display"></div>
            <button id="reset-button">Reset</button>
            <div id="debug-buttons">
                <button id="reveal-non-mines">Open Non-Mines</button>
                <button id="reveal-all">Open All</button>
            </div>
        </div>
    </div>

    <div id="timer-start-display"></div>

    <div id="popup-overlay"></div>
    <div id="rules-popup">
        <button id="close-popup-button" aria-label="閉じる">×</button>
        <div class="popup-header">
            <h2>ルールと設定</h2>
        </div>
        <div class="rules-content">
            <h3>基本ルール</h3>
            <p>クリックしてマスを開きます。<b>最初にクリックしたマスは必ず安全地帯です。</b><br>
                数字は周囲8マスにある地雷の数を示します。(ブラインド「あべこべ」有効時は安全地帯の数)<br>
                地雷のマスを開かずに、地雷以外のすべてのマスを開くとクリアです。<br>
                通常は、右クリック(PC)または長押し/旗モード(スマホ)で旗 (🚩) を立てられます。<br>
                <b>「フラグなしモード」</b>が有効な場合、旗を立てることはできません。<br>
                <b>「時限爆弾モード」</b>では制限時間内にクリアする必要があります。
                <b>「ブラインドモード」</b>では追加の制限ルールがランダムに適用されます。
            </p>

            <h3>ゲーム設定</h3>
            <div class="setting-section" data-setting-id="theme">
                <h4>テーマ設定</h4>
                <p>ライトモードとダークモードを切り替えます。<b>この設定は即時反映されます。</b></p>
                <div class="setting-label">
                    <span>ダークモード</span>
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle-switch">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            <div class="setting-section" id="pc-op-mode-section">
                <h4>PC操作モード</h4>
                <p style="margin-bottom: 8px;">マウス操作（右クリックで旗🚩を立てる）か、ボタン切り替え操作（画面上部の⛏️/🚩ボタン）かを選択します。<b>この設定は即時反映されます。</b><br>※フラグなしモード有効時は右クリック/🚩ボタンは無効です。</p>
                <label class="pc-op-mode-label">
                    <input type="radio" name="pc-op-mode" value="mouse" checked> マウス操作 (右クリックで🚩)
                </label>
                <label class="pc-op-mode-label">
                    <input type="radio" name="pc-op-mode" value="button"> ボタン切り替え操作 (⛏️/🚩)
                </label>
            </div>
            <div class="setting-section" data-rule-id="mines">
                <div class="slider-label">
                    <span>地雷の数:</span>
                    <span id="mine-count-display">50</span>
                    <button class="reset-rule-button" data-rule="mines">デフォルトに戻す</button>
                </div>
                <input type="range" id="mine-slider" min="0" max="400" value="50">
                <p style="font-size:10px; margin-top: 5px;">変更を適用するには「設定を保存」を押してください。</p>
            </div>
            <div class="setting-section" data-rule-id="noFlags">
                <h4>フラグなしモード (No Flags)</h4>
                <p>旗を立てる操作が無効になります。記憶力だけで挑戦！</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="noFlags">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="no-flags-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="setting-section" data-rule-id="timeBomb">
                <h4>時限爆弾モード (Time Bomb Mode)</h4>
                <p>制限時間内にクリアしないとゲームオーバーになります。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="timeBomb">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="time-bomb-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
                <div id="time-bomb-details" class="hidden-setting">
                    <div id="time-bomb-random-switch-label">
                        <span>ランダムな時間</span>
                        <label class="switch">
                            <input type="checkbox" id="time-bomb-random-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div id="time-bomb-random-settings" class="hidden-setting">
                        <div class="time-input-group">
                            <label for="time-bomb-min-hours">最小時間:</label>
                            <input type="number" id="time-bomb-min-hours" min="0" step="1" value="0"><span class="colon">:</span>
                            <input type="number" id="time-bomb-min-minutes" min="0" max="59" step="1" value="3"><span class="colon">:</span>
                            <input type="number" id="time-bomb-min-seconds" min="0" max="59" step="1" value="0">
                        </div>
                        <div class="time-input-group">
                            <label for="time-bomb-max-hours">最大時間:</label>
                            <input type="number" id="time-bomb-max-hours" min="0" step="1" value="0"><span class="colon">:</span>
                            <input type="number" id="time-bomb-max-minutes" min="0" max="59" step="1" value="8"><span class="colon">:</span>
                            <input type="number" id="time-bomb-max-seconds" min="0" max="59" step="1" value="0">
                        </div>
                        <span class="time-setting-note">(HH:MM:SS 形式)</span>
                    </div>
                    <div id="time-bomb-fixed-settings" class="hidden-setting">
                        <div class="time-input-group">
                            <label for="time-bomb-fixed-hours">時間設定:</label>
                            <input type="number" id="time-bomb-fixed-hours" min="0" step="1" value="0"><span class="colon">:</span>
                            <input type="number" id="time-bomb-fixed-minutes" min="0" max="59" step="1" value="5"><span class="colon">:</span>
                            <input type="number" id="time-bomb-fixed-seconds" min="0" max="59" step="1" value="0">
                        </div>
                        <span class="time-setting-note">(HH:MM:SS 形式)</span>
                    </div>
                    <div id="game-over-on-time-only-label">
                        <span>時間切れでのみゲームオーバー</span>
                        <label class="switch">
                            <input type="checkbox" id="game-over-on-time-only-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <p style="font-size:10px; margin-top: 0; text-align: center;">
                        有効時、地雷を踏むとペナルティ(15秒)が課されます。<br>ただし、全ての地雷を踏んだ場合もゲームオーバーになります。
                    </p>
                </div>
            </div>

            <h3>表示設定</h3>
            <div class="setting-section" data-rule-id="numbers">
                <h4>数字マス生成 (Numbers Squares)</h4>
                <p>オンの場合、地雷に隣接するマスに数字が表示されます。<br>
                    オフの場合、数字が表示されるべきマスは、可能な限り他の特殊マス (NaturalNumber, Directional, AreaValue, OddEven) に置き換えられ、残りはハイドマス (・) になります。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="numbers">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="number-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <h3>特殊マス設定</h3>
            <p>これらのマスは数字の代わりにヒントを表示します。同じ種類の特殊マス（ハイドマスを除く）は隣り合いません。「数字マス生成」がオフの場合、これらの設定は可能な限り適用されるようになります。<br>変更を適用するには「設定を保存」を押してください。</p>

            <div class="setting-section" data-rule-id="hide">
                <h4>ハイドマス (Concealment Squares)</h4>
                <p>数字が表示される代わりに「・」が表示されます。周囲の状況から数字を推測する必要があります。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="hide">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="hide-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
                <div id="hide-rate-control" class="enabled">
                    <div id="hide-rate-slider-label">
                        <span>最大割合:</span>
                        <span id="hide-rate-display">10%</span>
                    </div>
                    <input type="range" id="hide-rate-slider" min="5" max="50" step="5" value="10">
                </div>
            </div>

            <div class="setting-section" data-rule-id="directional">
                <h4>ディレクションマス (Directional Squares)</h4>
                <p>方向(<b>T</b>:上, <b>B</b>:下, <b>L</b>:左, <b>R</b>:右)とその方向にある地雷/安全地帯の数を表示します (例:「R4」)。<br>
                    指定された方向の地雷/安全地帯のみをカウントします。矢印が指す方向に最低1マス存在する場合のみ生成されます。同じ方向への連鎖はしません。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="directional">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="directional-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="setting-section" data-rule-id="oddEven">
                <h4>オッドイーブンマス (OddEven Squares)</h4>
                <p>数字の代わりに、周囲の地雷/安全地帯数が奇数(Odd)か偶数(Even)かを示します。「Ev」または「Od」で表示されます。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="oddEven">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="odd-even-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="setting-section" data-rule-id="areaValue">
                <h4>エリアバリューマス (Range Value Squares)</h4>
                <p>数字の代わりに、周囲の地雷/安全地帯数のおおよその範囲を示します。「~3」、「4~6」、「7~」で表示されます。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="areaValue">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="area-value-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="setting-section" data-rule-id="naturalNumber">
                <h4>ナチュラルナンバーマス (Natural Number Squares)</h4>
                <p>周囲の地雷/安全地帯数が素数(2,3,5,7)の場合はその数字を、素数でない場合(1,4,6,8)は最も近い素数との差を表示します。例えば、「-1」(1)、「±1」(4)、「+1」(8)のように表示されます。0の場合は「・」で表示されます。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="naturalNumber">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="natural-number-switch" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="setting-section" data-rule-id="blind">
                <p class="disabled-reason">No Flags または Time Bomb 有効時は選択不可</p>
                <h3>ブラインドモード (Blind Mode)</h3>
                <p>マインスイーパーを遊び尽くした人向け。有効にすると一部の設定が固定され、ランダムな追加ルールが適用されます。</p>
                <div class="setting-label">
                    <span>有効</span>
                    <div>
                        <button class="reset-rule-button" data-rule="blind">デフォルト</button>
                        <label class="switch">
                            <input type="checkbox" id="blind-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

        </div>
        <div class="popup-footer">
            <button id="reset-all-settings-button">全設定リセット</button>
            <button id="save-settings-button">設定を保存してリセット</button>
        </div>
    </div>

    <script>
        // --- Constants ---
        const gridSize = 20;
        const MINE_PENALTY_MS = 15000;
        const BASKETBALL_INTERVAL_MS = 10000;

        const defaultSettings = {
            numMines: 50,
            enableNoFlags: false,
            enableTimeBomb: false,
            timeLimitRandom: true,
            timeLimitMinMs: 180000,
            timeLimitMaxMs: 480000,
            timeLimitFixedMs: 300000,
            gameOverOnTimeOnly: false,
            enableNumbers: true,
            enableHide: true,
            hideRateMax: 0.10,
            enableDirectional: true,
            enableOddEven: true,
            enableAreaValue: true,
            enableNaturalNumber: true,
            enableBlind: false
        };

        // Blind Mode Constants
        const BLIND_MINE_MIN = 60;
        const BLIND_MINE_MAX = 120;
        const BLIND_HIDE_RATE = 0.20;
        const BLIND_DIRECTIONAL_RATE = 0.10;
        const BLIND_ODDEVEN_RATE = 0.10;
        const BLIND_AREAVALUE_RATE = 0.05;
        const BLIND_NATURALNUMBER_RATE = 0.05;
        const MIN_ERROR_RATE = 0.10;

        // --- Blind Rules Definition ---
        const blindRules = [{
                id: 'basketball',
                title: 'バスケットボール',
                description: '10秒に1回は安全なマスを開けなければならない',
                bgColor: '#ffe4e1',
                borderColor: '#dc143c'
            },
            {
                id: 'error',
                title: '過失誤差',
                description: '数字マスが±1されることがある',
                bgColor: '#fffacd',
                borderColor: '#ffd700'
            },
            {
                id: 'anomaly',
                title: '異常発生',
                description: '特定の特殊マスの生成率が増加する',
                bgColor: '#e6e6fa',
                borderColor: '#9370db'
            },
            {
                id: 'noChain',
                title: '完璧な感染対策',
                description: '0マスでの連鎖が発生しない',
                bgColor: '#f0fff0',
                borderColor: '#2e8b57'
            },
            {
                id: 'torus',
                title: 'トーラス',
                description: '盤面の上下左右の端がつながる',
                bgColor: '#add8e6',
                borderColor: '#4682b4'
            },
            {
                id: 'abekobe',
                title: 'あべこべ',
                description: '数字マスは安全地帯の数を示すようになる',
                bgColor: '#fafad2',
                borderColor: '#b8860b'
            }
        ];
        const specialSquareTypes = ['hide', 'directional', 'oddEven', 'areaValue', 'naturalNumber'];
        const specialSquareNamesJP = {
            hide: 'ハイドマス',
            directional: 'ディレクションマス',
            oddEven: 'オッドイーブンマス',
            areaValue: 'エリアバリューマス',
            naturalNumber: 'ナチュラルナンバーマス'
        };

        let numMines = defaultSettings.numMines;
        let currentMaxHideRate = defaultSettings.hideRateMax;
        let currentMaxOddEvenRate = 0.10;
        let currentMaxAreaValueRate = 0.03;
        let currentMaxDirectionalRate = 0.05;
        let currentMaxNaturalNumberRate = 0.05;

        // --- Board State ---
        let board = [];
        let minesLeft = numMines;
        let revealedNonMineCount = 0;
        let clickedMineCount = 0;
        let gameOver = false;
        let firstClickDone = false;
        let timerInterval = null;
        let elapsedMilliseconds = 0;
        let remainingMilliseconds = 0;
        let timeLimitMilliseconds = 0;
        const timerUpdateInterval = 50;
        let gameStarted = false;
        let startTime = 0;
        let penaltyOffsetMs = 0;

        // --- Interaction Mode State ---
        let currentInteractionMode = 'dig';
        let pcOperationMode = 'mouse';
        let isTouch = false;
        let justFlagged = false;

        // --- Blind Mode State ---
        let activeBlindRule = null;
        let basketballTimerInterval = null;
        let basketballRemainingMs = BASKETBALL_INTERVAL_MS;
        let basketballStartTime = 0;
        let anomalyTargetType = null;
        let currentAnomalyRate = 0;

        // --- Theme State ---
        let currentTheme = localStorage.getItem('minesweeperTheme') || 'light';

        // --- Get DOM Elements ---
        const boardElement = document.getElementById('board');
        const resetButton = document.getElementById('reset-button');
        const messageBox = document.getElementById('message-box');
        const timerContainer = document.getElementById('timer-container');
        const timerSpan = document.getElementById('timer-value');
        const body = document.body;
        const debugButtonsContainer = document.getElementById('debug-buttons');
        const revealNonMinesButton = document.getElementById('reveal-non-mines');
        const revealAllButton = document.getElementById('reveal-all');
        const rulesButton = document.getElementById('rules-button');
        const rulesPopup = document.getElementById('rules-popup');
        const closePopupButton = document.getElementById('close-popup-button');
        const popupOverlay = document.getElementById('popup-overlay');
        const numberSwitch = document.getElementById('number-switch');
        const hideSwitch = document.getElementById('hide-switch');
        const directionalSwitch = document.getElementById('directional-switch');
        const oddEvenSwitch = document.getElementById('odd-even-switch');
        const areaValueSwitch = document.getElementById('area-value-switch');
        const mineSlider = document.getElementById('mine-slider');
        const mineCountDisplay = document.getElementById('mine-count-display');
        const modeToggleButtonsContainer = document.getElementById('mode-toggle-buttons');
        const digModeButton = document.getElementById('dig-mode-button');
        const flagModeButton = document.getElementById('flag-mode-button');
        const pcOpModeRadios = document.querySelectorAll('input[name="pc-op-mode"]');
        const pcOpModeSection = document.getElementById('pc-op-mode-section');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const activeRulesDisplay = document.getElementById('active-rules-display');
        const hideRateSlider = document.getElementById('hide-rate-slider');
        const hideRateDisplay = document.getElementById('hide-rate-display');
        const hideRateControl = document.getElementById('hide-rate-control');
        const resetRuleButtons = document.querySelectorAll('.reset-rule-button');
        const noFlagsSwitch = document.getElementById('no-flags-switch');
        const naturalNumberSwitch = document.getElementById('natural-number-switch');
        const timeBombSwitch = document.getElementById('time-bomb-switch');
        const timeBombDetails = document.getElementById('time-bomb-details');
        const timeBombRandomSwitch = document.getElementById('time-bomb-random-switch');
        const timeBombRandomSettings = document.getElementById('time-bomb-random-settings');
        const timeBombFixedSettings = document.getElementById('time-bomb-fixed-settings');
        const timeBombMinHoursInput = document.getElementById('time-bomb-min-hours');
        const timeBombMinMinutesInput = document.getElementById('time-bomb-min-minutes');
        const timeBombMinSecondsInput = document.getElementById('time-bomb-min-seconds');
        const timeBombMaxHoursInput = document.getElementById('time-bomb-max-hours');
        const timeBombMaxMinutesInput = document.getElementById('time-bomb-max-minutes');
        const timeBombMaxSecondsInput = document.getElementById('time-bomb-max-seconds');
        const timeBombFixedHoursInput = document.getElementById('time-bomb-fixed-hours');
        const timeBombFixedMinutesInput = document.getElementById('time-bomb-fixed-minutes');
        const timeBombFixedSecondsInput = document.getElementById('time-bomb-fixed-seconds');
        const gameOverOnTimeOnlySwitch = document.getElementById('game-over-on-time-only-switch');
        const timerStartDisplay = document.getElementById('timer-start-display');
        const blindSwitch = document.getElementById('blind-switch');
        const blindRuleDisplay = document.getElementById('blind-rule-display');
        const minesSettingSection = document.querySelector('.setting-section[data-rule-id="mines"]');
        const noFlagsSettingSection = document.querySelector('.setting-section[data-rule-id="noFlags"]');
        const timeBombSettingSection = document.querySelector('.setting-section[data-rule-id="timeBomb"]');
        const numbersSettingSection = document.querySelector('.setting-section[data-rule-id="numbers"]');
        const hideSettingSection = document.querySelector('.setting-section[data-rule-id="hide"]');
        const directionalSettingSection = document.querySelector('.setting-section[data-rule-id="directional"]');
        const oddEvenSettingSection = document.querySelector('.setting-section[data-rule-id="oddEven"]');
        const areaValueSettingSection = document.querySelector('.setting-section[data-rule-id="areaValue"]');
        const naturalNumberSettingSection = document.querySelector('.setting-section[data-rule-id="naturalNumber"]');
        const blindSettingSection = document.querySelector('.setting-section[data-rule-id="blind"]');
        const themeToggleSwitch = document.getElementById('theme-toggle-switch');
        const resetAllSettingsButton = document.getElementById('reset-all-settings-button');

        // --- Settings (Current Applied) ---
        let enableNoFlags = defaultSettings.enableNoFlags;
        let enableTimeBomb = defaultSettings.enableTimeBomb;
        let timeLimitRandom = defaultSettings.timeLimitRandom;
        let timeLimitMinMs = defaultSettings.timeLimitMinMs;
        let timeLimitMaxMs = defaultSettings.timeLimitMaxMs;
        let timeLimitFixedMs = defaultSettings.timeLimitFixedMs;
        let gameOverOnTimeOnly = defaultSettings.gameOverOnTimeOnly;
        let enableNumbers = defaultSettings.enableNumbers;
        let enableHide = defaultSettings.enableHide;
        let hideRateMax = defaultSettings.hideRateMax;
        let enableDirectional = defaultSettings.enableDirectional;
        let enableOddEven = defaultSettings.enableOddEven;
        let enableAreaValue = defaultSettings.enableAreaValue;
        let enableNaturalNumber = defaultSettings.enableNaturalNumber;
        let enableBlind = defaultSettings.enableBlind;

        let pendingSettings = { ...defaultSettings
        };

        // --- Helper Functions ---

        function parseInputsToMs(hoursInput, minutesInput, secondsInput) {
            const h = parseInt(hoursInput?.value, 10) || 0;
            const m = parseInt(minutesInput?.value, 10) || 0;
            const s = parseInt(secondsInput?.value, 10) || 0;
            if (h < 0 || m < 0 || m > 59 || s < 0 || s > 59) {
                return null;
            }
            return (h * 3600 + m * 60 + s) * 1000;
        }


        function formatMsToInputs(ms, hoursInput, minutesInput, secondsInput) {
            if (typeof ms !== 'number' || ms < 0) {
                ms = 0;
            }
            const totalSeconds = Math.floor(ms / 1000);
            const seconds = totalSeconds % 60;
            const totalMinutes = Math.floor(totalSeconds / 60);
            const minutes = totalMinutes % 60;
            const hours = Math.floor(totalMinutes / 60);
            if (hoursInput) {
                hoursInput.value = String(hours);
            }
            if (minutesInput) {
                minutesInput.value = String(minutes);
            }
            if (secondsInput) {
                secondsInput.value = String(seconds);
            }
        }


        function formatMsToDisplayTime(ms, includeHoursForce = false) {
            if (typeof ms !== 'number' || ms < 0) {
                return '00:00';
            }
            const totalSeconds = Math.floor(ms / 1000);
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            const totalMinutes = Math.floor(totalSeconds / 60);
            const minutes = String(totalMinutes % 60).padStart(2, '0');
            const hours = Math.floor(totalMinutes / 60);
            if (includeHoursForce || hours > 0) {
                return `${String(hours).padStart(2, '0')}:${minutes}:${seconds}`;
            } else {
                return `${minutes}:${seconds}`;
            }
        }


        function initializeSliders() {
            const maxMines = gridSize * gridSize;
            if (mineSlider) {
                mineSlider.max = maxMines;
                let currentMineValue = pendingSettings.numMines;
                if (currentMineValue < 0) currentMineValue = 0;
                if (currentMineValue > maxMines) currentMineValue = maxMines;
                mineSlider.value = currentMineValue;
                if (mineCountDisplay) mineCountDisplay.textContent = currentMineValue;
            }
            if (hideRateSlider) {
                let currentHideRate = pendingSettings.hideRateMax * 100;
                const minHide = parseInt(hideRateSlider.min, 10);
                const maxHide = parseInt(hideRateSlider.max, 10);
                if (currentHideRate < minHide) currentHideRate = minHide;
                if (currentHideRate > maxHide) currentHideRate = maxHide;
                hideRateSlider.value = currentHideRate;
                if (hideRateDisplay) hideRateDisplay.textContent = `${Math.round(currentHideRate)}%`;
                if (hideRateControl) hideRateControl.classList.toggle('enabled', pendingSettings.enableHide && !pendingSettings.enableBlind);
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            applyTheme(currentTheme);
            if (themeToggleSwitch) themeToggleSwitch.checked = (currentTheme === 'dark');
            pendingSettings = { ...getCurrentSettings()
            };
            initializeSliders();
        });


        // --- Device Detection and UI Initialization ---

        function detectTouch() {
            isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouch) {
                document.body.classList.add('touch-device');
                pcOperationMode = 'button';
                const buttonRadio = document.querySelector('input[name="pc-op-mode"][value="button"]');
                if (buttonRadio) buttonRadio.checked = true;
            } else {
                document.body.classList.remove('touch-device');
                const currentPcOpRadio = document.querySelector(`input[name="pc-op-mode"][value="${pcOperationMode}"]`);
                if (!currentPcOpRadio) {
                    pcOperationMode = 'mouse';
                }
                const targetRadio = document.querySelector(`input[name="pc-op-mode"][value="${pcOperationMode}"]`);
                if (targetRadio) targetRadio.checked = true;
                document.body.dataset.pcOpMode = pcOperationMode;
            }
            updateModeButtonsVisibility();
        }


        function updateModeButtonsVisibility() {
            modeToggleButtonsContainer.classList.toggle('visible', isTouch || pcOperationMode === 'button');
            if (flagModeButton) flagModeButton.disabled = enableNoFlags;
        }


        // --- Theme Functions ---

        function applyTheme(theme) {
            document.body.dataset.theme = theme;
            localStorage.setItem('minesweeperTheme', theme);
            currentTheme = theme;
        }


        function toggleTheme() {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }


        // --- Helper: hasNeighborOfType ---

        function hasNeighborOfType(r, c, key) {
            const isTorus = enableBlind && activeBlindRule?.id === 'torus';
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    if (x === 0 && y === 0) continue;
                    let ni = r + x;
                    let nj = c + y;
                    let checkSquare = null;
                    if (isTorus) {
                        ni = (ni + gridSize) % gridSize;
                        nj = (nj + gridSize) % gridSize;
                        checkSquare = board[ni]?.[nj];
                    } else {
                        if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize) {
                            checkSquare = board[ni]?.[nj];
                        }
                    }
                    if (checkSquare && checkSquare[key]) return true;
                }
            }
            return false;
        }


        // --- Event Listeners ---
        if (resetButton) resetButton.addEventListener('click', resetGame);
        if (revealNonMinesButton) revealNonMinesButton.addEventListener('click', revealNonMines);
        if (revealAllButton) revealAllButton.addEventListener('click', revealAll);
        if (rulesButton) rulesButton.addEventListener('click', openPopup);
        if (closePopupButton) closePopupButton.addEventListener('click', closePopup);
        if (popupOverlay) popupOverlay.addEventListener('click', closePopup);
        if (numberSwitch) numberSwitch.addEventListener('change', () => {
            pendingSettings.enableNumbers = numberSwitch.checked;
        });
        if (hideSwitch) hideSwitch.addEventListener('change', () => {
            pendingSettings.enableHide = hideSwitch.checked;
            if(hideRateControl) hideRateControl.classList.toggle('enabled', pendingSettings.enableHide && !pendingSettings.enableBlind);
        });
        if (directionalSwitch) directionalSwitch.addEventListener('change', () => {
            pendingSettings.enableDirectional = directionalSwitch.checked;
        });
        if (oddEvenSwitch) oddEvenSwitch.addEventListener('change', () => {
            pendingSettings.enableOddEven = oddEvenSwitch.checked;
        });
        if (areaValueSwitch) areaValueSwitch.addEventListener('change', () => {
            pendingSettings.enableAreaValue = areaValueSwitch.checked;
        });
        if (noFlagsSwitch) noFlagsSwitch.addEventListener('change', () => {
            pendingSettings.enableNoFlags = noFlagsSwitch.checked;
            updateSettingsUI(pendingSettings);
        });
        if (naturalNumberSwitch) naturalNumberSwitch.addEventListener('change', () => {
            pendingSettings.enableNaturalNumber = naturalNumberSwitch.checked;
        });
        if (timeBombSwitch) timeBombSwitch.addEventListener('change', () => {
            pendingSettings.enableTimeBomb = timeBombSwitch.checked;
            updateSettingsUI(pendingSettings);
            updateTimeBombDetailsVisibility();
        });
        if (timeBombRandomSwitch) timeBombRandomSwitch.addEventListener('change', () => {
            pendingSettings.timeLimitRandom = timeBombRandomSwitch.checked;
            updateTimeBombInputVisibility();
        });
        if (gameOverOnTimeOnlySwitch) gameOverOnTimeOnlySwitch.addEventListener('change', () => {
            pendingSettings.gameOverOnTimeOnly = gameOverOnTimeOnlySwitch.checked;
        });
        if (blindSwitch) blindSwitch.addEventListener('change', () => {
            pendingSettings.enableBlind = blindSwitch.checked;
            updateSettingsUI(pendingSettings);
        });
        if (mineSlider) mineSlider.addEventListener('input', () => {
            const maxMines = gridSize * gridSize;
            let val = parseInt(mineSlider.value, 10);
            if (val > maxMines) val = maxMines;
            if (val < 0) val = 0;
            pendingSettings.numMines = val;
            if (mineCountDisplay) mineCountDisplay.textContent = pendingSettings.numMines;
        });
        if (hideRateSlider) hideRateSlider.addEventListener('input', () => {
            pendingSettings.hideRateMax = parseInt(hideRateSlider.value, 10) / 100;
            if (hideRateDisplay) hideRateDisplay.textContent = `${hideRateSlider.value}%`;
        });
        if (digModeButton) digModeButton.addEventListener('click', () => switchMode('dig'));
        if (flagModeButton) flagModeButton.addEventListener('click', () => switchMode('flag'));
        if (pcOpModeRadios) pcOpModeRadios.forEach(radio => radio.addEventListener('change', handlePcOperationModeChange));
        if (saveSettingsButton) saveSettingsButton.addEventListener('click', saveSettingsAndReset);
        if (resetRuleButtons) resetRuleButtons.forEach(button => button.addEventListener('click', handleResetRule));
        if (themeToggleSwitch) themeToggleSwitch.addEventListener('change', toggleTheme);
        if (resetAllSettingsButton) resetAllSettingsButton.addEventListener('click', handleResetAllSettings);


        function handleTimeInputChange() {
            let minMs = parseInputsToMs(timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
            let maxMs = parseInputsToMs(timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
            let fixedMs = parseInputsToMs(timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
            if (minMs !== null) {
                if (maxMs !== null && minMs > maxMs) {
                    maxMs = minMs;
                    formatMsToInputs(maxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
                }
                pendingSettings.timeLimitMinMs = minMs;
            } else {
                formatMsToInputs(pendingSettings.timeLimitMinMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
            }
            if (maxMs !== null) {
                if (minMs !== null && maxMs < minMs) {
                    minMs = maxMs;
                    formatMsToInputs(minMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
                    pendingSettings.timeLimitMinMs = minMs;
                }
                pendingSettings.timeLimitMaxMs = maxMs;
            } else {
                formatMsToInputs(pendingSettings.timeLimitMaxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
            }
            if (fixedMs !== null) {
                if (fixedMs <= 0) {
                    fixedMs = defaultSettings.timeLimitFixedMs;
                    formatMsToInputs(fixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
                }
                pendingSettings.timeLimitFixedMs = fixedMs;
            } else {
                formatMsToInputs(pendingSettings.timeLimitFixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
            }
        }

        [timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput].forEach(input => {
            if (input) {
                input.addEventListener('change', handleTimeInputChange);
            }
        });


        // --- Popup Functions ---

        function updateTimeBombDetailsVisibility() {
            const showDetails = pendingSettings.enableTimeBomb && !pendingSettings.enableBlind;
            if (timeBombDetails) timeBombDetails.classList.toggle('hidden-setting', !showDetails);
            if (showDetails) {
                updateTimeBombInputVisibility();
            }
        }


        function updateTimeBombInputVisibility() {
            if (timeBombRandomSettings && timeBombFixedSettings) {
                timeBombRandomSettings.classList.toggle('hidden-setting', !pendingSettings.timeLimitRandom);
                timeBombFixedSettings.classList.toggle('hidden-setting', pendingSettings.timeLimitRandom);
            }
        }


        function updateSettingsUI(settingsToUpdate) {
            const isBlindActive = settingsToUpdate.enableBlind;
            const isNoFlagsActive = settingsToUpdate.enableNoFlags;
            const isTimeBombActive = settingsToUpdate.enableTimeBomb;
            const blindDisabledSections = [minesSettingSection, noFlagsSettingSection, timeBombSettingSection, numbersSettingSection, hideSettingSection, directionalSettingSection, oddEvenSettingSection, areaValueSettingSection, naturalNumberSettingSection];
            blindDisabledSections.forEach(section => section?.classList.toggle('disabled-setting', isBlindActive));
            const disableBlindToggle = isNoFlagsActive || isTimeBombActive;
            if (blindSettingSection) blindSettingSection.classList.toggle('disabled-setting', disableBlindToggle);
            if (disableBlindToggle && settingsToUpdate.enableBlind) {
                settingsToUpdate.enableBlind = false;
                if (blindSwitch) blindSwitch.checked = false;
            }
            if (noFlagsSettingSection) noFlagsSettingSection.classList.toggle('disabled-setting', isBlindActive);
            if (timeBombSettingSection) timeBombSettingSection.classList.toggle('disabled-setting', isBlindActive);
            if (isBlindActive) {
                if (settingsToUpdate.enableNoFlags) {
                    settingsToUpdate.enableNoFlags = false;
                    if (noFlagsSwitch) noFlagsSwitch.checked = false;
                }
                if (settingsToUpdate.enableTimeBomb) {
                    settingsToUpdate.enableTimeBomb = false;
                    if (timeBombSwitch) timeBombSwitch.checked = false;
                }
            }
            if (hideRateControl) hideRateControl.classList.toggle('enabled', settingsToUpdate.enableHide && !isBlindActive);
            updateTimeBombDetailsVisibility();
        }


        function getCurrentSettings() {
            return {
                numMines: numMines,
                enableNoFlags: enableNoFlags,
                enableTimeBomb: enableTimeBomb,
                timeLimitRandom: timeLimitRandom,
                timeLimitMinMs: timeLimitMinMs,
                timeLimitMaxMs: timeLimitMaxMs,
                timeLimitFixedMs: timeLimitFixedMs,
                gameOverOnTimeOnly: gameOverOnTimeOnly,
                enableNumbers: enableNumbers,
                enableHide: enableHide,
                hideRateMax: hideRateMax,
                enableDirectional: enableDirectional,
                enableOddEven: enableOddEven,
                enableAreaValue: enableAreaValue,
                enableNaturalNumber: enableNaturalNumber,
                enableBlind: enableBlind
            };
        }


        function updatePopupUIFromSettings(settings) {
            pendingSettings = { ...settings
            };
            if (noFlagsSwitch) noFlagsSwitch.checked = settings.enableNoFlags;
            if (numberSwitch) numberSwitch.checked = settings.enableNumbers;
            if (hideSwitch) hideSwitch.checked = settings.enableHide;
            if (directionalSwitch) directionalSwitch.checked = settings.enableDirectional;
            if (oddEvenSwitch) oddEvenSwitch.checked = settings.enableOddEven;
            if (areaValueSwitch) areaValueSwitch.checked = settings.enableAreaValue;
            if (naturalNumberSwitch) naturalNumberSwitch.checked = settings.enableNaturalNumber;
            if (blindSwitch) blindSwitch.checked = settings.enableBlind;
            if (timeBombSwitch) timeBombSwitch.checked = settings.enableTimeBomb;
            if (timeBombRandomSwitch) timeBombRandomSwitch.checked = settings.timeLimitRandom;
            if (gameOverOnTimeOnlySwitch) gameOverOnTimeOnlySwitch.checked = settings.gameOverOnTimeOnly;
            if (mineSlider) initializeSliders();
            if (timeBombMinHoursInput) {
                formatMsToInputs(settings.timeLimitMinMs, timeBombMinHoursInput, timeBombMinMinutesInput, timeBombMinSecondsInput);
                formatMsToInputs(settings.timeLimitMaxMs, timeBombMaxHoursInput, timeBombMaxMinutesInput, timeBombMaxSecondsInput);
                formatMsToInputs(settings.timeLimitFixedMs, timeBombFixedHoursInput, timeBombFixedMinutesInput, timeBombFixedSecondsInput);
            }
            const targetPcOpRadio = document.querySelector(`input[name="pc-op-mode"][value="${pcOperationMode}"]`);
            if (targetPcOpRadio) targetPcOpRadio.checked = true;
            updateSettingsUI(pendingSettings);
        }


        function openPopup() {
            updatePopupUIFromSettings(getCurrentSettings());
            if (themeToggleSwitch) themeToggleSwitch.checked = (currentTheme === 'dark');
            if (rulesPopup && popupOverlay) {
                rulesPopup.classList.add('visible');
                popupOverlay.classList.add('visible');
            }
        }


        function closePopup() {
            if (rulesPopup && popupOverlay) {
                rulesPopup.classList.remove('visible');
                popupOverlay.classList.remove('visible');
            }
        }


        function handleResetRule(event) {
            const rule = event.target.dataset.rule;
            if (!rule) {
                return;
            }
            switch (rule) {
                case 'mines':
                    pendingSettings.numMines = defaultSettings.numMines;
                    break;
                case 'noFlags':
                    pendingSettings.enableNoFlags = defaultSettings.enableNoFlags;
                    break;
                case 'timeBomb':
                    pendingSettings.enableTimeBomb = defaultSettings.enableTimeBomb;
                    pendingSettings.timeLimitRandom = defaultSettings.timeLimitRandom;
                    pendingSettings.timeLimitMinMs = defaultSettings.timeLimitMinMs;
                    pendingSettings.timeLimitMaxMs = defaultSettings.timeLimitMaxMs;
                    pendingSettings.timeLimitFixedMs = defaultSettings.timeLimitFixedMs;
                    pendingSettings.gameOverOnTimeOnly = defaultSettings.gameOverOnTimeOnly;
                    break;
                case 'numbers':
                    pendingSettings.enableNumbers = defaultSettings.enableNumbers;
                    break;
                case 'hide':
                    pendingSettings.enableHide = defaultSettings.enableHide;
                    pendingSettings.hideRateMax = defaultSettings.hideRateMax;
                    break;
                case 'directional':
                    pendingSettings.enableDirectional = defaultSettings.enableDirectional;
                    break;
                case 'oddEven':
                    pendingSettings.enableOddEven = defaultSettings.enableOddEven;
                    break;
                case 'areaValue':
                    pendingSettings.enableAreaValue = defaultSettings.enableAreaValue;
                    break;
                case 'naturalNumber':
                    pendingSettings.enableNaturalNumber = defaultSettings.enableNaturalNumber;
                    break;
                case 'blind':
                    pendingSettings.enableBlind = defaultSettings.enableBlind;
                    break;
            }
            updatePopupUIFromSettings(pendingSettings);
        }


        function handleResetAllSettings() {
            updatePopupUIFromSettings(defaultSettings);
        }


        function saveSettingsAndReset() {
            if (pendingSettings.enableTimeBomb && !pendingSettings.enableBlind) {
                handleTimeInputChange();
            }
            enableBlind = pendingSettings.enableBlind;
            if (enableBlind) {
                numMines = Math.floor(Math.random() * (BLIND_MINE_MAX - BLIND_MINE_MIN + 1)) + BLIND_MINE_MIN;
                enableNoFlags = false;
                enableTimeBomb = false;
                gameOverOnTimeOnly = false;
                enableNumbers = true;
                enableHide = true;
                hideRateMax = BLIND_HIDE_RATE;
                enableDirectional = true;
                enableOddEven = true;
                enableAreaValue = true;
                enableNaturalNumber = true;
            } else {
                numMines = pendingSettings.numMines;
                enableNoFlags = pendingSettings.enableNoFlags;
                enableTimeBomb = pendingSettings.enableTimeBomb;
                timeLimitRandom = pendingSettings.timeLimitRandom;
                timeLimitMinMs = pendingSettings.timeLimitMinMs;
                timeLimitMaxMs = pendingSettings.timeLimitMaxMs;
                timeLimitFixedMs = pendingSettings.timeLimitFixedMs;
                gameOverOnTimeOnly = pendingSettings.gameOverOnTimeOnly;
                enableNumbers = pendingSettings.enableNumbers;
                enableHide = pendingSettings.enableHide;
                hideRateMax = pendingSettings.hideRateMax;
                enableDirectional = pendingSettings.enableDirectional;
                enableOddEven = pendingSettings.enableOddEven;
                enableAreaValue = pendingSettings.enableAreaValue;
                enableNaturalNumber = pendingSettings.enableNaturalNumber;
            }
            const maxMines = gridSize * gridSize;
            if (numMines > maxMines) numMines = maxMines;
            if (numMines < 0) numMines = 0;
            updateNoFlagsUI();
            resetGame();
            closePopup();
        }


        function handlePcOperationModeChange(event) {
            pcOperationMode = event.target.value;
            document.body.dataset.pcOpMode = pcOperationMode;
            updateModeButtonsVisibility();
            switchMode('dig');
        }


        function switchMode(newMode) {
            if ((enableNoFlags && newMode === 'flag') || newMode === currentInteractionMode) {
                return;
            }
            currentInteractionMode = newMode;
            if (digModeButton) digModeButton.classList.toggle('active', newMode === 'dig');
            if (flagModeButton) flagModeButton.classList.toggle('active', newMode === 'flag');
        }


        function updateActiveRulesDisplay() {
            let rulesHtml = '';
            if (enableBlind) {
                rulesHtml += `<div class="rule-display-blind">Blind Mode Active!</div>`;
            } else {
                if (enableNoFlags) {
                    rulesHtml += `<div class="rule-display-noFlags">No Flags</div>`;
                }
                if (enableTimeBomb) {
                    const timeDesc = timeLimitMilliseconds > 0 ? formatMsToDisplayTime(timeLimitMilliseconds, true) : 'Setting...';
                    rulesHtml += `<div class="rule-display-timeBomb">Time Bomb (${timeDesc})</div>`;
                    if (gameOverOnTimeOnly) {
                        rulesHtml += `<div class="rule-display-gameOverOnTimeOnly">Game Over on Time Only</div>`;
                    }
                }
                if (!enableNumbers) {
                    rulesHtml += `<div class="rule-display-noNumbers">No Numbers</div>`;
                }
                if (enableHide) {
                    rulesHtml += `<div class="rule-display-hide">Concealment Sq. (${Math.round(hideRateMax*100)}% Max)</div>`;
                }
                if (enableDirectional) {
                    rulesHtml += `<div class="rule-display-directional">Directional Squares</div>`;
                }
                if (enableOddEven) {
                    rulesHtml += `<div class="rule-display-oddEven">OddEven Squares</div>`;
                }
                if (enableAreaValue) {
                    rulesHtml += `<div class="rule-display-areaValue">Range Value Squares</div>`;
                }
                if (enableNaturalNumber) {
                    rulesHtml += `<div class="rule-display-naturalNumber">Natural Number Squares</div>`;
                }
                if (!rulesHtml) {
                    rulesHtml = '<div class="rule-display-standard">Standard Rules</div>';
                }
            }
            if (activeRulesDisplay) activeRulesDisplay.innerHTML = rulesHtml;
        }


        function updateBlindRuleDisplay() {
            if (enableBlind && activeBlindRule) {
                let description = activeBlindRule.description;
                if (activeBlindRule.id === 'anomaly' && anomalyTargetType) {
                    const targetNameJP = specialSquareNamesJP[anomalyTargetType] || anomalyTargetType;
                    description = `${targetNameJP}の最大生成率が${Math.round(currentAnomalyRate * 100)}%になる`;
                }
                if (blindRuleDisplay) {
                    blindRuleDisplay.innerHTML = `<strong>Blind: ${activeBlindRule.title}</strong><span>${description}</span>`;
                    // Apply specific colors based on the active rule
                    blindRuleDisplay.style.backgroundColor = activeBlindRule.bgColor || 'var(--blind-rule-base-bg)'; // Fallback to base
                    blindRuleDisplay.style.borderColor = activeBlindRule.borderColor || 'var(--blind-rule-base-border)'; // Fallback to base
                    blindRuleDisplay.classList.add('visible');
                }
            } else {
                if (blindRuleDisplay) {
                    blindRuleDisplay.classList.remove('visible');
                    blindRuleDisplay.innerHTML = '';
                    // Reset inline styles to use CSS variables
                    blindRuleDisplay.style.backgroundColor = '';
                    blindRuleDisplay.style.borderColor = '';
                }
            }
        }


        function updateNoFlagsUI() {
            const flagsAllowed = !enableNoFlags;
            body.setAttribute('data-flags-enabled', String(flagsAllowed));
            if (flagModeButton) flagModeButton.disabled = !flagsAllowed;
            if (!flagsAllowed && currentInteractionMode === 'flag') {
                switchMode('dig');
            }
            updateModeButtonsVisibility();
        }


        // --- Game Logic Functions ---

        function resetGame() {
            gameOver = true;
            firstClickDone = false;
            clearInterval(timerInterval);
            timerInterval = null;
            clearInterval(basketballTimerInterval);
            basketballTimerInterval = null;
            elapsedMilliseconds = 0;
            remainingMilliseconds = 0;
            timeLimitMilliseconds = 0;
            basketballRemainingMs = BASKETBALL_INTERVAL_MS;
            startTime = 0;
            basketballStartTime = 0;
            gameStarted = false;
            revealedNonMineCount = 0;
            clickedMineCount = 0;
            penaltyOffsetMs = 0;
            minesLeft = numMines;
            switchMode('dig');
            activeBlindRule = null;
            anomalyTargetType = null;
            currentAnomalyRate = 0;
            messageBox.textContent = 'Click a square to start!';
            body.classList.remove('game-over', 'low-time', 'timer-intro-active', 'game-clear');
            timerContainer.classList.remove('blinking-black', 'blinking-red', 'blinking-basketball', 'hide-during-intro');
            timerStartDisplay.classList.remove('visible', 'move-to-corner');
            timerStartDisplay.style.animation = 'none';
            debugButtonsContainer.classList.remove('visible');
            updateBlindRuleDisplay(); // Reset blind display style
            updateTimerDisplay();
            updateActiveRulesDisplay();
            updateNoFlagsUI();
            setTimeout(createBoard, 50);
        }


        function createBoard() {
            board = [];
            gameOver = false;
            firstClickDone = false;
            revealedNonMineCount = 0;
            clickedMineCount = 0;
            penaltyOffsetMs = 0;
            boardElement.innerHTML = '';
            activeBlindRule = null;
            anomalyTargetType = null;
            currentAnomalyRate = 0;
            minesLeft = numMines;
            if (enableBlind) {
                activeBlindRule = blindRules[Math.floor(Math.random() * blindRules.length)];
                minesLeft = numMines;
                currentMaxHideRate = BLIND_HIDE_RATE;
                currentMaxDirectionalRate = BLIND_DIRECTIONAL_RATE;
                currentMaxOddEvenRate = BLIND_ODDEVEN_RATE;
                currentMaxAreaValueRate = BLIND_AREAVALUE_RATE;
                currentMaxNaturalNumberRate = BLIND_NATURALNUMBER_RATE;
                if (activeBlindRule.id === 'anomaly') {
                    anomalyTargetType = specialSquareTypes[Math.floor(Math.random() * specialSquareTypes.length)];
                    currentAnomalyRate = Math.random() * (0.75 - 0.50) + 0.50;
                    console.log(`Anomaly Target: ${anomalyTargetType}, Rate: ${currentAnomalyRate}`);
                }
                updateBlindRuleDisplay(); // Update display (potentially with color)
            } else {
                updateBlindRuleDisplay(); // Ensure blind display is hidden/reset
                currentMaxHideRate = hideRateMax;
                currentMaxOddEvenRate = 0.10;
                currentMaxAreaValueRate = 0.03;
                currentMaxDirectionalRate = 0.05;
                currentMaxNaturalNumberRate = 0.05;
                if (enableTimeBomb) {
                    timeLimitMilliseconds = timeLimitRandom ? Math.floor(Math.random() * (Math.max(0, timeLimitMaxMs) - Math.max(0, timeLimitMinMs) + 1)) + Math.max(0, timeLimitMinMs) : Math.max(1000, timeLimitFixedMs);
                    remainingMilliseconds = timeLimitMilliseconds;
                    updateTimerDisplay();
                } else {
                    timeLimitMilliseconds = 0;
                    elapsedMilliseconds = 0;
                    updateTimerDisplay();
                }
            }
            for (let i = 0; i < gridSize; i++) {
                board[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    board[i][j] = {
                        isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0,
                        originalAdjacentMines: 0, adjacentSafe: 0, isHide: false, isOddEven: false,
                        isAreaValue: false, isDirectional: false, isNaturalNumber: false,
                        oddEvenValue: null, areaValue: null, direction: null, directionalCount: null,
                        directionalSymbol: null, naturalNumberValue: null, isAdjusted: false,
                        element: document.createElement('div')
                    };
                    const sq = board[i][j];
                    const el = sq.element;
                    el.classList.add('square', 'hidden');
                    el.dataset.row = i;
                    el.dataset.col = j;
                    el.addEventListener('click', () => handleSquareInteraction(i, j));
                    el.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (!isTouch && pcOperationMode === 'mouse' && !enableNoFlags && !gameOver) {
                            handleFlagAction(i, j);
                        }
                    });
                    let pt;
                    el.addEventListener('touchstart', (e) => {
                        if (isTouch && !enableNoFlags && !gameOver) {
                            clearTimeout(pt);
                            pt = setTimeout(() => {
                                e.preventDefault();
                                handleFlagAction(i, j);
                                justFlagged = true;
                                setTimeout(() => { justFlagged = false; }, 50);
                            }, 500);
                        }
                    }, { passive: false });
                    el.addEventListener('touchend', () => clearTimeout(pt));
                    el.addEventListener('touchmove', () => clearTimeout(pt));
                    boardElement.appendChild(el);
                }
            }
            updateMinesLeftDisplay(); // Set initial message
            updateActiveRulesDisplay();
            updateNoFlagsUI();
            if (enableTimeBomb && !enableBlind && timeLimitMilliseconds > 0) {
                timerContainer.classList.add('hide-during-intro');
                setTimeout(startTimerAnimation, 100);
            } else {
                timerContainer.classList.remove('hide-during-intro');
            }
            detectTouch();
        }


        function startTimerAnimation() {
            if (!enableTimeBomb || enableBlind || timeLimitMilliseconds <= 0) {
                return;
            }
            const includeHours = timeLimitMilliseconds >= 3600000;
            timerStartDisplay.textContent = formatMsToDisplayTime(timeLimitMilliseconds, includeHours);
            timerStartDisplay.style.animation = 'start-blink 1s infinite';
            timerStartDisplay.classList.add('visible');
            body.classList.add('timer-intro-active');
            setTimeout(() => {
                if (body.classList.contains('timer-intro-active')) {
                    timerStartDisplay.classList.add('move-to-corner');
                }
            }, 1200);
            setTimeout(() => {
                if (body.classList.contains('timer-intro-active')) {
                    timerStartDisplay.classList.remove('visible', 'move-to-corner');
                    timerStartDisplay.style.animation = 'none';
                    timerContainer.classList.remove('hide-during-intro');
                    body.classList.remove('timer-intro-active');
                }
            }, 1600);
        }


        function initializeBoardAfterFirstClick(firstClickRow, firstClickCol) {
            plantMines(firstClickRow, firstClickCol);
            calculateAdjacentMines();
            applySpecialSquares();
            updateMinesLeftDisplay(); // Update display AFTER mines are planted
            debugButtonsContainer.classList.add('visible');
        }


        function plantMines(avoidRow, avoidCol) {
            let minesPlanted = 0;
            const maxPossible = gridSize * gridSize;
            let currentNumMines = numMines;
            const forbidden = new Set();
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    const nr = avoidRow + x;
                    const nc = avoidCol + y;
                    if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                        forbidden.add(`${nr}-${nc}`);
                    }
                }
            }
            const availableSquares = maxPossible - forbidden.size;
            if (currentNumMines > availableSquares) {
                console.warn(`Mine count reduced from ${currentNumMines} to ${availableSquares} due to safe start area.`);
                currentNumMines = availableSquares;
                numMines = currentNumMines;
                minesLeft = currentNumMines; // Update minesLeft immediately
                if (rulesPopup.classList.contains('visible') && !enableBlind && mineSlider) {
                    mineSlider.value = numMines;
                    if (mineCountDisplay) mineCountDisplay.textContent = numMines;
                    pendingSettings.numMines = numMines;
                }
            } else {
                minesLeft = currentNumMines; // Set minesLeft based on final count
            }
            if (currentNumMines < 0) currentNumMines = 0;
            if (currentNumMines >= maxPossible) currentNumMines = maxPossible - 1;
            while (minesPlanted < currentNumMines) {
                const r = Math.floor(Math.random() * gridSize);
                const c = Math.floor(Math.random() * gridSize);
                const posKey = `${r}-${c}`;
                if (board[r]?.[c] && !board[r][c].isMine && !forbidden.has(posKey)) {
                    board[r][c].isMine = true;
                    minesPlanted++;
                }
            }
        }


        function calculateAdjacentMines() {
            const isTorus = enableBlind && activeBlindRule?.id === 'torus';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const currentSquare = board[i]?.[j];
                    if (!currentSquare) continue;
                    if (currentSquare.isMine) {
                        currentSquare.adjacentMines = -1;
                        currentSquare.originalAdjacentMines = -1;
                        currentSquare.adjacentSafe = -1;
                        continue;
                    }
                    let mineCount = 0;
                    let safeCount = 0;
                    for (let x = -1; x <= 1; x++) {
                        for (let y = -1; y <= 1; y++) {
                            if (x === 0 && y === 0) continue;
                            let ni = i + x;
                            let nj = j + y;
                            let isValidNeighbor = false;
                            let neighborSquare = null;
                            if (isTorus) {
                                ni = (ni + gridSize) % gridSize;
                                nj = (nj + gridSize) % gridSize;
                                isValidNeighbor = true;
                                neighborSquare = board[ni]?.[nj];
                            } else {
                                isValidNeighbor = ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize;
                                if (isValidNeighbor) {
                                    neighborSquare = board[ni]?.[nj];
                                }
                            }
                            if (isValidNeighbor && neighborSquare) {
                                if (neighborSquare.isMine) {
                                    mineCount++;
                                } else {
                                    safeCount++;
                                }
                            }
                        }
                    }
                    currentSquare.originalAdjacentMines = mineCount;
                    currentSquare.adjacentSafe = safeCount;
                    currentSquare.adjacentMines = mineCount;
                    currentSquare.isAdjusted = false;
                }
            }
        }


        function countSafeInDirection(r, c, dx, dy) {
            const isTorus = enableBlind && activeBlindRule?.id === 'torus';
            let count = 0;
            let cr = r + dx;
            let cc = c + dy;
            let steps = 0;
            const maxSteps = gridSize * 2;
            while (steps < maxSteps) {
                let checkR = cr;
                let checkC = cc;
                let inBounds = false;
                if (isTorus) {
                    checkR = (cr + gridSize) % gridSize;
                    checkC = (cc + gridSize) % gridSize;
                    if (steps > 0 && checkR === r && checkC === c) break;
                    inBounds = true;
                } else {
                    inBounds = checkR >= 0 && checkR < gridSize && checkC >= 0 && checkC < gridSize;
                }
                if (!inBounds) break;
                if (board[checkR]?.[checkC] && !board[checkR][checkC].isMine) count++;
                cr += dx;
                cc += dy;
                steps++;
            }
            return count;
        }


        function countMinesInDirection(r, c, dx, dy) {
            const isTorus = enableBlind && activeBlindRule?.id === 'torus';
            let count = 0;
            let cr = r + dx;
            let cc = c + dy;
            let steps = 0;
            const maxSteps = gridSize * 2;
            while (steps < maxSteps) {
                let checkR = cr;
                let checkC = cc;
                let inBounds = false;
                if (isTorus) {
                    checkR = (cr + gridSize) % gridSize;
                    checkC = (cc + gridSize) % gridSize;
                    if (steps > 0 && checkR === r && checkC === c) break;
                    inBounds = true;
                } else {
                    inBounds = checkR >= 0 && checkR < gridSize && checkC >= 0 && checkC < gridSize;
                }
                if (!inBounds) break;
                if (board[checkR]?.[checkC] && board[checkR][checkC].isMine) count++;
                cr += dx;
                cc += dy;
                steps++;
            }
            return count;
        }


        function calculateNaturalNumberValue(n) {
            const p = [2, 3, 5, 7];
            if (typeof n !== 'number' || n < 0 || n > 8) {
                console.warn(`Unexpected value passed to calculateNaturalNumberValue: ${n}`);
                return '・';
            }
            if (p.includes(n)) return String(n);
            switch (n) {
                case 0:
                    return '・';
                case 1:
                    return "-1";
                case 4:
                    return "±1";
                case 6:
                    return "±1";
                case 8:
                    return "+1";
                default:
                    return '・';
            }
        }


        function applySpecialSquares() {
            const potentialSquares = [];
            const errorTargetSquares = [];
            const isAbekobe = enableBlind && activeBlindRule?.id === 'abekobe';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const square = board[i]?.[j];
                    if (!square) continue;
                    square.isHide = square.isOddEven = square.isAreaValue = square.isDirectional = square.isNaturalNumber = false;
                    square.oddEvenValue = square.areaValue = square.direction = square.directionalCount = square.directionalSymbol = square.naturalNumberValue = null;
                    square.isAdjusted = false;
                    square.adjacentMines = isAbekobe ? square.adjacentSafe : square.originalAdjacentMines;
                    const relevantCount = square.adjacentMines;
                    if (!square.isMine && relevantCount >= 0) {
                        if (relevantCount > 0 || isAbekobe || enableHide || enableOddEven || enableNaturalNumber) {
                            potentialSquares.push({ r: i, c: j });
                        }
                    }
                    if (!square.isMine && square.originalAdjacentMines > 0 && !isAbekobe) {
                        errorTargetSquares.push({ r: i, c: j });
                    }
                }
            }
            potentialSquares.sort(() => Math.random() - 0.5);
            errorTargetSquares.sort(() => Math.random() - 0.5);
            const assignedCoordinates = new Set();
            const numPotential = potentialSquares.length;
            const isBlindAnomaly = enableBlind && activeBlindRule?.id === 'anomaly';
            let rateHide = currentMaxHideRate, rateDirectional = currentMaxDirectionalRate, rateOddEven = currentMaxOddEvenRate, rateAreaValue = currentMaxAreaValueRate, rateNaturalNumber = currentMaxNaturalNumberRate;
            if (isBlindAnomaly && anomalyTargetType) {
                switch (anomalyTargetType) {
                    case 'hide': rateHide = currentAnomalyRate; break;
                    case 'directional': rateDirectional = currentAnomalyRate; break;
                    case 'oddEven': rateOddEven = currentAnomalyRate; break;
                    case 'areaValue': rateAreaValue = currentAnomalyRate; break;
                    case 'naturalNumber': rateNaturalNumber = currentAnomalyRate; break;
                }
            }
            const baseDirections = [{ dx: -1, dy: 0, s: 'T', n: 'up' }, { dx: 1, dy: 0, s: 'B', n: 'down' }, { dx: 0, dy: -1, s: 'L', n: 'left' }, { dx: 0, dy: 1, s: 'R', n: 'right' }];

            function hasDirChain(r, c, dx, dy) {
                const isTorus = enableBlind && activeBlindRule?.id === 'torus';
                let nr = r + dx;
                let nc = c + dy;
                if (isTorus) {
                    nr = (nr + gridSize) % gridSize;
                    nc = (nc + gridSize) % gridSize;
                }
                if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                    const nextSquare = board[nr]?.[nc];
                    return nextSquare?.isDirectional && nextSquare.direction?.dx === dx && nextSquare.direction?.dy === dy;
                }
                return false;
            }

            function getValidDirs(r, c) {
                const isTorus = enableBlind && activeBlindRule?.id === 'torus';
                return baseDirections.filter(dir => {
                    const nr = r + dir.dx;
                    const nc = c + dir.dy;
                    if (isTorus) return true;
                    return nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize;
                });
            }
            const ruleOrder = [
                { t: 'areaValue', e: enableAreaValue, r: rateAreaValue, c: (s, r, c) => !hasNeighborOfType(r, c, 'isAreaValue') },
                { t: 'naturalNumber', e: enableNaturalNumber, r: rateNaturalNumber, c: (s, r, c) => !hasNeighborOfType(r, c, 'isNaturalNumber') },
                { t: 'directional', e: enableDirectional, r: rateDirectional, c: (s, r, c) => !hasNeighborOfType(r, c, 'isDirectional') },
                { t: 'oddEven', e: enableOddEven, r: rateOddEven, c: (s, r, c) => !hasNeighborOfType(r, c, 'isOddEven') },
                { t: 'hide', e: enableHide, r: rateHide, c: () => true }
            ];
            for (const rule of ruleOrder) {
                const ruleEnabled = enableBlind || rule.e;
                const isActiveSetting = (rule.t === 'hide' && enableHide) || (rule.t === 'directional' && enableDirectional) || (rule.t === 'oddEven' && enableOddEven) || (rule.t === 'areaValue' && enableAreaValue) || (rule.t === 'naturalNumber' && enableNaturalNumber);
                if (ruleEnabled && isActiveSetting && numPotential > 0) {
                    const currentRate = (rule.t === 'hide' ? rateHide : rule.t === 'directional' ? rateDirectional : rule.t === 'oddEven' ? rateOddEven : rule.t === 'areaValue' ? rateAreaValue : rule.t === 'naturalNumber' ? rateNaturalNumber : 0);
                    const maxCount = Math.floor(numPotential * currentRate);
                    let currentCount = 0;
                    for (const { r, c } of potentialSquares) {
                        if (currentCount >= maxCount) break;
                        const coordKey = `${r}-${c}`;
                        const square = board[r]?.[c];
                        if (!square || assignedCoordinates.has(coordKey)) continue;
                        const neighborCheckPassed = enableBlind || rule.c(square, r, c);
                        if (neighborCheckPassed) {
                            const countForCalc = square.adjacentMines;
                            let applied = false;
                            if (rule.t === 'directional') {
                                const validDirs = getValidDirs(r, c);
                                if (validDirs.length > 0) {
                                    const shuffledDirs = [...validDirs].sort(() => Math.random() - 0.5);
                                    for (const dir of shuffledDirs) {
                                        if (!hasDirChain(r, c, dir.dx, dir.dy)) {
                                            const dirCount = isAbekobe ? countSafeInDirection(r, c, dir.dx, dir.dy) : countMinesInDirection(r, c, dir.dx, dir.dy);
                                            if (dirCount > 0) {
                                                square.isDirectional = true;
                                                square.isHide = true;
                                                square.direction = { dx: dir.dx, dy: dir.dy, name: dir.n };
                                                square.directionalCount = dirCount;
                                                square.directionalSymbol = dir.s;
                                                applied = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            } else if (rule.t === 'areaValue' && countForCalc > 0) {
                                square.isAreaValue = true;
                                square.isHide = true;
                                if (countForCalc <= 3) square.areaValue = '~3';
                                else if (countForCalc <= 6) square.areaValue = '4~6';
                                else square.areaValue = '7~';
                                applied = true;
                            } else if (rule.t === 'oddEven') {
                                square.isOddEven = true;
                                square.isHide = true;
                                square.oddEvenValue = countForCalc % 2 === 0 ? 'Ev' : 'Od';
                                applied = true;
                            } else if (rule.t === 'naturalNumber' && countForCalc >= 0) {
                                const nnValue = calculateNaturalNumberValue(countForCalc);
                                if (nnValue !== '・') {
                                    square.isNaturalNumber = true;
                                    square.isHide = true;
                                    square.naturalNumberValue = nnValue;
                                    applied = true;
                                } else if (enableHide) { // Convert 0 to Hide only if Hide rule is enabled
                                    square.isHide = true;
                                    square.isNaturalNumber = false; // Ensure it's not marked as NN
                                    applied = true;
                                }
                            } else if (rule.t === 'hide') {
                                square.isHide = true;
                                applied = true;
                            }
                            if (applied) {
                                assignedCoordinates.add(coordKey);
                                currentCount++;
                            }
                        }
                    }
                }
            }
            if (enableBlind && activeBlindRule?.id === 'error') {
                const numErrorTargets = errorTargetSquares.length;
                const minAffectedCount = Math.ceil(numErrorTargets * MIN_ERROR_RATE);
                let affectedCount = 0;
                for (let i = 0; i < numErrorTargets && affectedCount < minAffectedCount; i++) {
                    const { r, c } = errorTargetSquares[i];
                    const square = board[r]?.[c];
                    if (square && !square.isAdjusted && !square.isDirectional && !square.isAreaValue && !square.isOddEven && !square.isNaturalNumber) {
                        const adjustUp = Math.random() < 0.5;
                        const originalValue = square.adjacentMines;
                        if (adjustUp && originalValue < 8) {
                            square.adjacentMines++;
                            square.isAdjusted = true;
                            affectedCount++;
                        } else if (!adjustUp && originalValue > 0) {
                            square.adjacentMines--;
                            square.isAdjusted = true;
                            affectedCount++;
                        }
                    }
                }
                for (let i = 0; i < numErrorTargets; i++) {
                    const { r, c } = errorTargetSquares[i];
                    const square = board[r]?.[c];
                    if (square && !square.isAdjusted && !square.isDirectional && !square.isAreaValue && !square.isOddEven && !square.isNaturalNumber) {
                        const rand = Math.random();
                        const originalValue = square.adjacentMines;
                        if (rand < 0.25 && originalValue < 8) {
                            square.adjacentMines++;
                            square.isAdjusted = true;
                        } else if (rand < 0.50 && originalValue > 0) {
                            square.adjacentMines--;
                            square.isAdjusted = true;
                        }
                    }
                }
            }
        }


        // --- Interaction and Rendering Functions ---

        function handleSquareInteraction(r, c) {
            const targetSquare = board[r]?.[c];
            if (gameOver || !targetSquare || targetSquare.isRevealed || justFlagged) {
                return;
            }
            if (!firstClickDone) {
                firstClickDone = true;
                initializeBoardAfterFirstClick(r, c);
                startGameTimer();
                messageBox.textContent = ''; // Clear initial message now handled by updateMinesLeftDisplay
                revealSquare(r, c);
                checkWinCondition();
                return;
            }
            const square = targetSquare;
            if (currentInteractionMode === 'flag') {
                if (!enableNoFlags) {
                    handleFlagAction(r, c);
                }
            } else {
                if (square.isFlagged && !enableNoFlags) {
                    return;
                }
                if (square.isMine) {
                    if (!square.isRevealed) {
                        revealMine(r, c);
                        clickedMineCount++;
                        if (enableTimeBomb && !enableBlind && gameOverOnTimeOnly) {
                            penaltyOffsetMs += MINE_PENALTY_MS;
                            body.style.transition = 'background-color 0.1s ease-out';
                            body.style.backgroundColor = '#ffdddd';
                            setTimeout(() => {
                                body.style.transition = 'background-color 0.3s ease';
                                body.style.backgroundColor = '';
                                const currentRemainingAfterPenalty = timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs;
                                const isStillLowTime = currentRemainingAfterPenalty < 60000 && currentRemainingAfterPenalty > 0;
                                body.classList.toggle('low-time', isStillLowTime);
                                updateTimerDisplay();
                            }, 150);
                            setTimeout(() => {
                                const currentRemaining = timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs;
                                if ((clickedMineCount >= numMines || currentRemaining <= 0) && !gameOver) {
                                    endGame(false);
                                }
                            }, timerUpdateInterval + 10);
                        } else {
                            endGame(false);
                        }
                    }
                } else {
                    revealSquare(r, c);
                    checkWinCondition();
                }
            }
        }


        function startGameTimer() {
            if (gameStarted) {
                return;
            }
            gameStarted = true;
            startTime = Date.now();
            penaltyOffsetMs = 0;
            if (enableTimeBomb && !enableBlind) {
                if (timeLimitMilliseconds <= 0) {
                    console.warn("Time Bomb enabled but time limit is zero.");
                }
            } else {
                elapsedMilliseconds = 0;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            if (basketballTimerInterval) {
                clearInterval(basketballTimerInterval);
            }
            timerInterval = setInterval(updateTimer, timerUpdateInterval);
            if (enableBlind && activeBlindRule?.id === 'basketball') {
                basketballStartTime = Date.now();
                basketballRemainingMs = BASKETBALL_INTERVAL_MS;
                basketballTimerInterval = setInterval(updateBasketballTimer, timerUpdateInterval);
                timerContainer.classList.add('blinking-basketball');
            }
            updateTimerDisplay();
        }


        function resetBasketballTimer() {
            if (enableBlind && activeBlindRule?.id === 'basketball' && gameStarted && !gameOver) {
                basketballStartTime = Date.now();
                basketballRemainingMs = BASKETBALL_INTERVAL_MS;
                timerContainer.classList.add('blinking-basketball');
                updateTimerDisplay();
            }
        }


        function handleFlagAction(r, c) {
            const sq = board[r]?.[c];
            if (enableNoFlags || gameOver || !firstClickDone || !sq || sq.isRevealed) {
                return;
            }
            sq.isFlagged = !sq.isFlagged;
            if (sq.isFlagged) {
                minesLeft--;
            } else {
                minesLeft++;
            }
            renderSquareContent(sq);
            updateMinesLeftDisplay();
        }


        function revealMine(r, c) {
            const sq = board[r]?.[c];
            if (sq && !sq.isRevealed) {
                sq.isRevealed = true;
                sq.element.classList.add('mine-clicked');
                renderSquareContent(sq);
            }
        }


        function revealSquare(r, c) {
            const isTorus = enableBlind && activeBlindRule?.id === 'torus';
            let checkR = r;
            let checkC = c;
            if (isTorus) {
                checkR = (r + gridSize) % gridSize;
                checkC = (c + gridSize) % gridSize;
                if (checkR < 0) checkR += gridSize;
                if (checkC < 0) checkC += gridSize;
            }
            if (checkR < 0 || checkR >= gridSize || checkC < 0 || checkC >= gridSize || gameOver) {
                return;
            }
            const sq = board[checkR]?.[checkC];
            if (!sq || sq.isRevealed || sq.isMine || (sq.isFlagged && !enableNoFlags)) {
                return;
            }
            sq.isRevealed = true;
            revealedNonMineCount++;
            resetBasketballTimer();
            renderSquareContent(sq);
            const canChain = !(enableBlind && activeBlindRule?.id === 'noChain');
            if (sq.originalAdjacentMines === 0 && canChain && !sq.isDirectional && !sq.isAreaValue && !sq.isOddEven && !sq.isNaturalNumber && !sq.isHide) {
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        if (x !== 0 || y !== 0) {
                            revealSquare(checkR + x, checkC + y);
                        }
                    }
                }
            }
        }


        function renderSquareContent(sq) {
            const el = sq.element;
            if (!el) return;
            const keepClasses = ['mine-clicked', 'flag-wrong'].filter(cls => el.classList.contains(cls));
            el.className = 'square';
            keepClasses.forEach(cls => el.classList.add(cls));
            el.textContent = '';
            el.innerHTML = '';
            el.style.fontSize = ''; // Reset specific styles potentially set
            el.style.lineHeight = ''; // Reset specific styles potentially set
            el.classList.remove('number-adjusted');
            if (!sq.isRevealed) {
                el.classList.add('hidden');
                const flagsAllowed = !enableNoFlags;
                if (sq.isFlagged && flagsAllowed) {
                    el.textContent = '🚩';
                    el.classList.add('flagged');
                }
            } else {
                el.classList.add('revealed');
                if (sq.isMine) {
                    el.classList.add('mine');
                    el.textContent = el.classList.contains('mine-clicked') ? '💥' : '💣';
                } else {
                    if (el.classList.contains('flag-wrong')) {
                        el.textContent = '❌';
                    } else if (sq.isDirectional) {
                        el.classList.add('directional-square', 'special-square');
                        el.textContent = sq.directionalSymbol + sq.directionalCount;
                    } else if (sq.isAreaValue) {
                        el.classList.add('area-value-square', 'special-square');
                        if (sq.areaValue === '4~6') {
                            el.innerHTML = '4~<br>6';
                            el.style.lineHeight = '0.9'; // Keep specific style if needed
                        } else {
                            el.textContent = sq.areaValue;
                        }
                    } else if (sq.isOddEven) {
                        el.classList.add('odd-even-square', 'special-square');
                        el.textContent = sq.oddEvenValue;
                    } else if (sq.isNaturalNumber) {
                        el.classList.add('natural-number-square', 'special-square');
                        el.textContent = sq.naturalNumberValue;
                    } else if (sq.isHide) {
                        el.classList.add('special-square');
                        el.textContent = '・';
                    } else if (sq.adjacentMines >= 0) {
                        el.textContent = sq.adjacentMines > 0 ? sq.adjacentMines : '';
                        if (sq.adjacentMines > 0) {
                            el.classList.add(`number-${sq.adjacentMines}`);
                        }
                        if (sq.isAdjusted && enableBlind && activeBlindRule?.id === 'error') {
                            el.classList.add('number-adjusted');
                        }
                    } else {
                        el.textContent = '';
                        el.classList.add('revealed');
                    }
                }
            }
        }


        function updateMinesLeftDisplay() {
            if (!firstClickDone) {
                messageBox.textContent = 'Click a square to start!';
            } else {
                messageBox.textContent = `Mines: ${minesLeft}`;
            }
        }


        function checkWinCondition() {
            if (gameOver || !firstClickDone) {
                return;
            }
            const totalNonMineSquares = (gridSize * gridSize) - numMines;
            if (revealedNonMineCount >= totalNonMineSquares) {
                let allSafeRevealed = true;
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const sq = board[i]?.[j];
                        if (sq && !sq.isMine && !sq.isRevealed) {
                            allSafeRevealed = false;
                            break;
                        }
                    }
                    if (!allSafeRevealed) break;
                }
                if (allSafeRevealed) {
                    if (enableTimeBomb && !enableBlind && remainingMilliseconds <= 0 && gameStarted) {
                        return;
                    }
                    if (enableBlind && activeBlindRule?.id === 'basketball' && basketballRemainingMs <= 0 && gameStarted) {
                        return;
                    }
                    endGame(true);
                }
            }
        }


        function endGame(isWin) {
            if (gameOver) {
                return;
            }
            gameOver = true;
            clearInterval(timerInterval);
            timerInterval = null;
            clearInterval(basketballTimerInterval);
            basketballTimerInterval = null;
            body.classList.remove('low-time', 'timer-intro-active');
            timerContainer.classList.remove('blinking-black', 'blinking-red', 'blinking-basketball');
            debugButtonsContainer.classList.remove('visible');
            let finalDisplayMillis = 0;
            if (gameStarted) {
                if (enableBlind || !enableTimeBomb) {
                    elapsedMilliseconds = Date.now() - startTime;
                    finalDisplayMillis = elapsedMilliseconds;
                } else {
                    remainingMilliseconds = Math.max(0, timeLimitMilliseconds - (Date.now() - startTime) - penaltyOffsetMs);
                    finalDisplayMillis = remainingMilliseconds;
                }
            } else {
                finalDisplayMillis = (enableTimeBomb && !enableBlind) ? timeLimitMilliseconds : 0;
            }
            if (isWin) {
                messageBox.textContent = 'Game Clear!';
                body.classList.add('game-clear');
                const flagsAllowed = !enableNoFlags;
                if (flagsAllowed) {
                    let minesToFlag = 0;
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            const sq = board[i]?.[j];
                            if (sq && sq.isMine && !sq.isFlagged) {
                                sq.isFlagged = true;
                                renderSquareContent(sq);
                                minesToFlag++;
                            }
                        }
                    }
                    minesLeft -= minesToFlag;
                    if (minesLeft < 0) minesLeft = 0;
                    updateMinesLeftDisplay();
                }
                if (gameStarted) {
                    if (enableTimeBomb && !enableBlind) {
                        const h = Math.floor(finalDisplayMillis / 3600000);
                        const m = Math.floor((finalDisplayMillis % 3600000) / 60000);
                        const s = Math.floor((finalDisplayMillis % 60000) / 1000);
                        const cs = Math.floor((finalDisplayMillis % 1000) / 10);
                        if (finalDisplayMillis < 3600000) {
                            timerSpan.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
                        } else {
                            timerSpan.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
                        }
                    } else {
                        updateTimerDisplay(finalDisplayMillis);
                    }
                } else {
                    timerSpan.textContent = (enableTimeBomb && !enableBlind) ? formatMsToDisplayTime(timeLimitMilliseconds, true) : '00.00';
                }
            } else {
                if (messageBox.textContent !== 'Game Clear!') {
                    if (enableBlind && activeBlindRule?.id === 'basketball' && basketballRemainingMs <= 0 && gameStarted) {
                        messageBox.textContent = 'Time Up! (Basketball)';
                    } else if (enableTimeBomb && !enableBlind && gameOverOnTimeOnly && clickedMineCount >= numMines) {
                        messageBox.textContent = 'All Mines Hit!';
                    } else if (enableTimeBomb && !enableBlind && remainingMilliseconds <= 0 && gameStarted) {
                        messageBox.textContent = 'Time Up!';
                    } else {
                        messageBox.textContent = 'Game Over!';
                    }
                }
                body.classList.add('game-over');
                revealAllMines(true);
                updateTimerDisplay(finalDisplayMillis);
            }
        }


        function revealAllMines(showIncorrectFlags) {
            const flagsAllowed = !enableNoFlags;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const sq = board[i]?.[j];
                    if (!sq) continue;
                    const el = sq.element;
                    if (sq.isMine) {
                        if ((sq.isFlagged && flagsAllowed) || el.classList.contains('mine-clicked')) {
                            continue;
                        }
                        sq.isRevealed = true;
                        renderSquareContent(sq);
                    } else {
                        if (showIncorrectFlags && sq.isFlagged && flagsAllowed) {
                            sq.isRevealed = true;
                            el.className = 'square revealed flag-wrong';
                            el.textContent = '❌';
                        } else if (showIncorrectFlags && !sq.isRevealed) {
                            sq.isRevealed = true;
                            renderSquareContent(sq);
                        }
                    }
                }
            }
        }


        // --- Timer Functions ---

        function updateTimer() {
            if (!gameStarted || gameOver) {
                if (timerInterval && gameOver) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                return;
            }
            const now = Date.now();
            if (enableTimeBomb && !enableBlind) {
                const elapsed = now - startTime;
                remainingMilliseconds = timeLimitMilliseconds - elapsed - penaltyOffsetMs;
                if (remainingMilliseconds <= 0) {
                    remainingMilliseconds = 0;
                    updateTimerDisplay();
                    clearInterval(timerInterval);
                    timerInterval = null;
                    if (!gameOver) {
                        endGame(false);
                    }
                } else {
                    updateTimerDisplay();
                    const isLowTime = remainingMilliseconds < 60000;
                    body.classList.toggle('low-time', isLowTime);
                    timerContainer.classList.toggle('blinking-red', isLowTime);
                    timerContainer.classList.toggle('blinking-black', !isLowTime);
                }
            } else {
                elapsedMilliseconds = now - startTime;
                updateTimerDisplay();
                body.classList.remove('low-time');
                timerContainer.classList.remove('blinking-red', 'blinking-black');
            }
        }


        function updateBasketballTimer() {
            if (!gameStarted || gameOver || !enableBlind || activeBlindRule?.id !== 'basketball') {
                if (basketballTimerInterval) {
                    clearInterval(basketballTimerInterval);
                    basketballTimerInterval = null;
                }
                return;
            }
            const elapsedBasketball = Date.now() - basketballStartTime;
            basketballRemainingMs = BASKETBALL_INTERVAL_MS - elapsedBasketball;
            if (basketballRemainingMs <= 0) {
                basketballRemainingMs = 0;
                updateTimerDisplay();
                clearInterval(basketballTimerInterval);
                basketballTimerInterval = null;
                if (!gameOver) {
                    endGame(false);
                }
            } else {
                updateTimerDisplay();
                timerContainer.classList.toggle('blinking-basketball', basketballRemainingMs <= 3000);
            }
        }


        function updateTimerDisplay(forceMillis = null) {
            if (gameOver && enableTimeBomb && !enableBlind && messageBox.textContent === 'Game Clear!' && forceMillis === null) {
                return;
            }
            let displayMillis;
            let isBasketballActive = enableBlind && activeBlindRule?.id === 'basketball' && gameStarted && !gameOver;
            if (forceMillis !== null) {
                displayMillis = forceMillis;
            } else if (isBasketballActive) {
                displayMillis = basketballRemainingMs;
            } else if (enableTimeBomb && !enableBlind) {
                displayMillis = remainingMilliseconds;
            } else {
                displayMillis = elapsedMilliseconds;
            }
            const safeMillis = Math.max(0, displayMillis);
            let formattedTime;
            if (isBasketballActive) {
                const s = Math.floor(safeMillis / 1000);
                const cs = Math.floor((safeMillis % 1000) / 10);
                formattedTime = `${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
            } else if (safeMillis < 60000 && (enableTimeBomb && !enableBlind)) {
                const s = Math.floor(safeMillis / 1000);
                const cs = Math.floor((safeMillis % 1000) / 10);
                formattedTime = `${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
            } else if (safeMillis < 3600000) {
                const m = Math.floor(safeMillis / 60000);
                const s = Math.floor((safeMillis % 60000) / 1000);
                formattedTime = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            } else {
                const h = Math.floor(safeMillis / 3600000);
                const m = Math.floor((safeMillis % 3600000) / 60000);
                const s = Math.floor((safeMillis % 60000) / 1000);
                formattedTime = `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }
            if (!gameStarted && !(enableTimeBomb && !enableBlind)) {
                formattedTime = "00.00";
            }
            if (timerSpan) timerSpan.textContent = formattedTime;
            if (!isBasketballActive) {
                if (timerContainer) timerContainer.classList.remove('blinking-basketball');
                if (enableTimeBomb && !enableBlind && gameStarted && !gameOver) {
                    /* Blink handled in updateTimer */
                } else {
                    body.classList.remove('low-time');
                    if (timerContainer) timerContainer.classList.remove('blinking-red', 'blinking-black');
                }
            } else {
                body.classList.remove('low-time');
                if (timerContainer) timerContainer.classList.remove('blinking-red', 'blinking-black');
            }
        }


        // --- Debug Functions ---

        function revealNonMines() {
            if (gameOver || !firstClickDone) {
                return;
            }
            if (!gameStarted) {
                startGameTimer();
            }
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const sq = board[i]?.[j];
                    if (sq && !sq.isMine && !sq.isRevealed) {
                        revealSquare(i, j);
                    }
                }
            }
            if (!gameOver) {
                endGame(true);
            }
            messageBox.textContent = 'All non-mines revealed!';
        }


        function revealAll() {
            if (gameOver || !firstClickDone) {
                return;
            }
            if (!gameStarted) {
                startGameTimer();
            }
            revealAllMines(true);
            if (!gameOver) {
                endGame(false);
            }
            messageBox.textContent = 'All squares revealed!';
        }


        // --- Initial Setup ---
        applyTheme(currentTheme);
        if (themeToggleSwitch) themeToggleSwitch.checked = (currentTheme === 'dark');
        updateTimerDisplay();
        updateActiveRulesDisplay();
        updateNoFlagsUI();
        detectTouch();
        createBoard();
    </script>
</body>
</html>
